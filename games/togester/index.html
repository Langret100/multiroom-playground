<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no, maximum-scale=1.0">
    <title>ğŸ¹ íˆ¬ê²ŒìŠ¤í„° - í˜‘ë™ í”Œë«í¼ ê²Œì„</title>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Jua&family=Black+Han+Sans&display=swap');
        
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
            touch-action: none;
            -webkit-touch-callout: none;
            -webkit-user-select: none;
            user-select: none;
        }
        
        body {
            background: linear-gradient(135deg, #1a1a2e 0%, #16213e 50%, #0f3460 100%);
            min-height: 100vh;
            font-family: 'Jua', sans-serif;
            overflow: hidden;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
        }
        
        #lobby {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            z-index: 1000;
            padding: 20px;
        }
        
        #lobby.hidden {
            display: none;
        }
        
        .lobby-title {
            font-family: 'Black Han Sans', sans-serif;
            font-size: clamp(2rem, 8vw, 4rem);
            color: #fff;
            text-shadow: 4px 4px 0 #e94560, 8px 8px 0 rgba(0,0,0,0.2);
            margin-bottom: 10px;
            animation: bounce 1s ease infinite;
        }
        
        @keyframes bounce {
            0%, 100% { transform: translateY(0); }
            50% { transform: translateY(-10px); }
        }
        
        .lobby-subtitle {
            color: rgba(255,255,255,0.9);
            font-size: clamp(0.9rem, 3vw, 1.2rem);
            margin-bottom: 30px;
        }
        
        .cat-parade {
            display: flex;
            gap: 15px;
            margin-bottom: 30px;
        }
        
        .cat-preview {
            width: 50px;
            height: 55px;
            animation: parade 0.5s ease infinite alternate;
        }
        
        .cat-preview:nth-child(2) { animation-delay: 0.1s; }
        .cat-preview:nth-child(3) { animation-delay: 0.2s; }
        .cat-preview:nth-child(4) { animation-delay: 0.3s; }
        
        @keyframes parade {
            from { transform: translateY(0) rotate(-5deg); }
            to { transform: translateY(-10px) rotate(5deg); }
        }
        
        .input-group {
            margin-bottom: 15px;
            width: 100%;
            max-width: 300px;
        }
        
        .input-group label {
            display: block;
            color: rgba(255,255,255,0.9);
            margin-bottom: 5px;
            font-size: 0.9rem;
        }
        
        .input-group input {
            width: 100%;
            padding: 12px 16px;
            border: none;
            border-radius: 25px;
            font-size: 1rem;
            font-family: 'Jua', sans-serif;
            background: rgba(255,255,255,0.95);
            box-shadow: 0 4px 15px rgba(0,0,0,0.2);
        }
        
        .btn {
            padding: 15px 40px;
            font-size: 1.1rem;
            font-family: 'Black Han Sans', sans-serif;
            border: none;
            border-radius: 30px;
            cursor: pointer;
            transition: all 0.3s ease;
            margin: 8px;
            box-shadow: 0 4px 15px rgba(0,0,0,0.3);
        }
        
        .btn-create {
            background: linear-gradient(135deg, #00b894 0%, #00cec9 100%);
            color: white;
        }
        
        .btn-join {
            background: linear-gradient(135deg, #e17055 0%, #d63031 100%);
            color: white;
        }
        
        .btn-guest {
            background: linear-gradient(135deg, #a29bfe 0%, #6c5ce7 100%);
            color: white;
            width: 100%;
            max-width: 280px;
        }
        
        .btn:hover {
            transform: translateY(-3px) scale(1.05);
            box-shadow: 0 8px 25px rgba(0,0,0,0.4);
        }
        
        .btn:active {
            transform: translateY(0) scale(0.98);
        }
        
        #gameContainer {
            position: relative;
            width: 100%;
            height: 100vh;
            display: flex;
            flex-direction: column;
        }
        
        #gameHeader {
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            padding: 8px 10px;
            background: rgba(0,0,0,0.5);
            backdrop-filter: blur(10px);
            display: flex;
            justify-content: space-between;
            align-items: center;
            gap: 8px;
            flex-wrap: nowrap;
            z-index: 100;
        }

        #gameHeader > * { white-space: nowrap; }

        .header-right{
            display:flex;
            align-items:center;
            gap:8px;
            flex-wrap:nowrap;
        }

        .exit-btn{
            background: rgba(255,255,255,0.14);
            border: 1px solid rgba(255,255,255,0.22);
            color: #fff;
            padding: 6px 10px;
            border-radius: 14px;
            font-family: 'Jua', sans-serif;
            font-size: 0.85rem;
            cursor: pointer;
        }
        .exit-btn:active{ transform: scale(0.98); }

        @media (max-width: 420px){
            .room-code{ display:none; }
            .exit-btn{ padding: 6px 8px; font-size: 0.8rem; }
            .level-info{ font-size: 0.85rem; }
        }

        
        .room-code {
            background: rgba(255,255,255,0.2);
            padding: 5px 15px;
            border-radius: 20px;
            color: #fff;
            font-size: 0.9rem;
        }
        
        .level-info {
            color: #ffd700;
            font-size: 0.9rem;
        }
        
        .death-count {
            color: #ff6b6b;
            font-size: 0.82rem;
            background: rgba(255,107,107,0.2);
            padding: 3px 8px;
            border-radius: 10px;
        }
        
        #gameCanvas {
            flex: 1;
            width: 100%;
        }
        
        #playerList {
            position: absolute;
            top: 60px;
            right: 10px;
            background: rgba(0,0,0,0.6);
            backdrop-filter: blur(5px);
            padding: 10px;
            border-radius: 10px;
            z-index: 100;
        }
        
        .player-item {
            display: flex;
            align-items: center;
            gap: 8px;
            margin: 5px 0;
            color: white;
            font-size: 0.85rem;
        }
        
        .player-dot {
            width: 12px;
            height: 12px;
            border-radius: 50%;
        }
        
        #controls-hint {
            position: absolute;
            bottom: 20px;
            left: 50%;
            transform: translateX(-50%);
            background: rgba(0,0,0,0.7);
            color: white;
            padding: 10px 20px;
            border-radius: 20px;
            font-size: 0.75rem;
            text-align: center;
            z-index: 100;
            opacity: 0.8;
            max-width: 90%;
            white-space: nowrap;
        }
        
        #winScreen {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0,0,0,0.8);
            display: none;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            z-index: 2000;
        }
        
        #winScreen.show {
            display: flex;
        }
        
        .win-text {
            font-family: 'Black Han Sans', sans-serif;
            font-size: clamp(2rem, 10vw, 5rem);
            color: #ffd700;
            text-shadow: 0 0 30px rgba(255,215,0,0.5);
            animation: pulse 0.5s ease infinite alternate;
        }
        
        @keyframes pulse {
            from { transform: scale(1); }
            to { transform: scale(1.1); }
        }
        
        .firebase-config {
            margin-top: 20px;
            padding: 15px;
            background: rgba(255,255,255,0.1);
            border-radius: 15px;
            max-width: 300px;
            width: 100%;
        }
        
        .firebase-config summary {
            color: rgba(255,255,255,0.8);
            cursor: pointer;
            font-size: 0.9rem;
        }
        
        .firebase-config input {
            width: 100%;
            padding: 8px 12px;
            margin: 5px 0;
            border: none;
            border-radius: 8px;
            font-size: 0.85rem;
            background: rgba(255,255,255,0.9);
        }
        
        .error-msg {
            color: #ff6b6b;
            background: rgba(255,107,107,0.2);
            padding: 10px;
            border-radius: 10px;
            margin-top: 10px;
            font-size: 0.9rem;
            display: none;
        }
        
        .error-msg.show {
            display: block;
        }
    </style>
</head>
<body>
    <!-- ë¡œë¹„ í™”ë©´ -->
    <div id="lobby">
        <h1 class="lobby-title">ğŸ¹ íˆ¬ê²ŒìŠ¤í„°</h1>
        <p class="lobby-subtitle">ìµœëŒ€ 4ëª…ì´ í•¨ê»˜í•˜ëŠ” í˜‘ë™ í”Œë«í¼ ê²Œì„!</p>
        
        <div class="cat-parade">
            <svg class="cat-preview" viewBox="0 0 40 40">
                <circle cx="20" cy="22" r="16" fill="#ff6b6b"/>
                <circle cx="8" cy="10" r="6" fill="#ff6b6b"/>
                <circle cx="32" cy="10" r="6" fill="#ff6b6b"/>
                <circle cx="8" cy="10" r="3" fill="#ffb8b8"/>
                <circle cx="32" cy="10" r="3" fill="#ffb8b8"/>
                <circle cx="14" cy="20" r="2.5" fill="#2d3436"/>
                <circle cx="26" cy="20" r="2.5" fill="#2d3436"/>
                <circle cx="15" cy="19" r="1" fill="white"/>
                <circle cx="27" cy="19" r="1" fill="white"/>
                <ellipse cx="9" cy="26" rx="5" ry="4" fill="#ffb8b8" opacity="0.7"/>
                <ellipse cx="31" cy="26" rx="5" ry="4" fill="#ffb8b8" opacity="0.7"/>
            </svg>
            <svg class="cat-preview" viewBox="0 0 40 40">
                <circle cx="20" cy="22" r="16" fill="#4ecdc4"/>
                <circle cx="8" cy="10" r="6" fill="#4ecdc4"/>
                <circle cx="32" cy="10" r="6" fill="#4ecdc4"/>
                <circle cx="8" cy="10" r="3" fill="#ffb8b8"/>
                <circle cx="32" cy="10" r="3" fill="#ffb8b8"/>
                <circle cx="14" cy="20" r="2.5" fill="#2d3436"/>
                <circle cx="26" cy="20" r="2.5" fill="#2d3436"/>
                <circle cx="15" cy="19" r="1" fill="white"/>
                <circle cx="27" cy="19" r="1" fill="white"/>
                <ellipse cx="9" cy="26" rx="5" ry="4" fill="#ffb8b8" opacity="0.7"/>
                <ellipse cx="31" cy="26" rx="5" ry="4" fill="#ffb8b8" opacity="0.7"/>
            </svg>
            <svg class="cat-preview" viewBox="0 0 40 40">
                <circle cx="20" cy="22" r="16" fill="#ffe66d"/>
                <circle cx="8" cy="10" r="6" fill="#ffe66d"/>
                <circle cx="32" cy="10" r="6" fill="#ffe66d"/>
                <circle cx="8" cy="10" r="3" fill="#ffb8b8"/>
                <circle cx="32" cy="10" r="3" fill="#ffb8b8"/>
                <circle cx="14" cy="20" r="2.5" fill="#2d3436"/>
                <circle cx="26" cy="20" r="2.5" fill="#2d3436"/>
                <circle cx="15" cy="19" r="1" fill="white"/>
                <circle cx="27" cy="19" r="1" fill="white"/>
                <ellipse cx="9" cy="26" rx="5" ry="4" fill="#ffb8b8" opacity="0.7"/>
                <ellipse cx="31" cy="26" rx="5" ry="4" fill="#ffb8b8" opacity="0.7"/>
            </svg>
            <svg class="cat-preview" viewBox="0 0 40 40">
                <circle cx="20" cy="22" r="16" fill="#a29bfe"/>
                <circle cx="8" cy="10" r="6" fill="#a29bfe"/>
                <circle cx="32" cy="10" r="6" fill="#a29bfe"/>
                <circle cx="8" cy="10" r="3" fill="#ffb8b8"/>
                <circle cx="32" cy="10" r="3" fill="#ffb8b8"/>
                <circle cx="14" cy="20" r="2.5" fill="#2d3436"/>
                <circle cx="26" cy="20" r="2.5" fill="#2d3436"/>
                <circle cx="15" cy="19" r="1" fill="white"/>
                <circle cx="27" cy="19" r="1" fill="white"/>
                <ellipse cx="9" cy="26" rx="5" ry="4" fill="#ffb8b8" opacity="0.7"/>
                <ellipse cx="31" cy="26" rx="5" ry="4" fill="#ffb8b8" opacity="0.7"/>
            </svg>
        </div>
        
        <div class="input-group">
            <label>ë‹‰ë„¤ì„</label>
            <input type="text" id="playerName" placeholder="í–„ìŠ¤í„° ì´ë¦„ì„ ì…ë ¥í•˜ì„¸ìš”" maxlength="10">
        </div>
        
        <div class="input-group">
            <label>ë°© ì½”ë“œ (ì°¸ê°€ì‹œ)</label>
            <input type="text" id="roomCode" placeholder="ë°© ì½”ë“œ ì…ë ¥" maxlength="6" style="text-transform: uppercase;">
        </div>
        
        <div>
            <button class="btn btn-create" onclick="createRoom()">ğŸ  ë°© ë§Œë“¤ê¸°</button>
            <button class="btn btn-join" onclick="joinRoom()">ğŸšª ì°¸ê°€í•˜ê¸°</button>
        </div>
        
        <div style="margin-top: 15px;">
            <button class="btn btn-guest" onclick="startGuestMode()">ğŸ® í˜¼ì ì—°ìŠµí•˜ê¸°</button>
        </div>
        
        <div id="errorMsg" class="error-msg"></div>
    </div>
    
    <!-- ê²Œì„ í™”ë©´ -->
    <div id="gameContainer" style="display:none;">
        <div id="gameHeader">
            <span class="room-code" id="displayRoomCode">ë°©: ----</span>
            <span class="level-info" id="levelInfo">ë ˆë²¨ 1</span>
            <div class="header-right">
                <span class="death-count" id="deathCount">ğŸ’€ 0</span>
                <button class="exit-btn" id="exitBtn" type="button">ë‚˜ê°€ê¸°</button>
            </div>
        </div>
        
        <canvas id="gameCanvas"></canvas>
        
        <div id="playerList"></div>
        
        <div id="controls-hint">
            ì™¼ìª½/ì˜¤ë¥¸ìª½ í„°ì¹˜: ì´ë™ | ì–‘ìª½ í„°ì¹˜: ì í”„
        </div>
    </div>
    
    <!-- ìŠ¹ë¦¬ í™”ë©´ -->
    <div id="winScreen">
        <div class="win-text">ğŸ‰ ë ˆë²¨ í´ë¦¬ì–´! ğŸ‰</div>
        <div id="autoNextHint" style="color: #aaa; margin-top: 15px; font-size: 0.9rem;">ì ì‹œ í›„ ë‹¤ìŒ ë ˆë²¨ë¡œ...</div>
    </div>

    <!-- ë°°ê²½ìŒì•… (ê²Œì„ ì§„í–‰ ì¤‘ ë°˜ë³µ ì¬ìƒ) -->
    <audio id="bgm" src="togestermusic.mp3" loop preload="auto"></audio>
<script>
        // ==================== ì„¤ì • ====================
        // Firebase ì˜ì¡´ì„± ì œê±° (Colyseus/ë¶€ëª¨ ë¸Œë¦¿ì§€ë¡œ ë™ê¸°í™”)
        const EMBED = new URLSearchParams(location.search).get('embed') === '1';
        const EMBED_PRACTICE = EMBED && (new URLSearchParams(location.search).get('practice') === '1');
        function bridgeSend(type, payload){
            if (!EMBED) return;
            try { window.parent && window.parent.postMessage({ type, ...payload }, '*'); } catch(e){}
        }

        // ==================== ê²Œì„ ìƒíƒœ ====================
        let db = null;
        let roomRef = null;
        let playerId = null;
        let roomId = null;
        let isHost = false;
        let isGuestMode = false;
        let currentLevel = 1;
        let levelClearLock = false; // ë ˆë²¨ í´ë¦¬ì–´ ì¤‘ë³µ íŠ¸ë¦¬ê±° ë°©ì§€
        
        const HAMSTER_COLORS = ['#ff6b6b', '#4ecdc4', '#ffe66d', '#a29bfe'];
        const JUMP_VELOCITY = -13.3334; // ì í”„ 2ë°° (ëª¨ë°”ì¼ ì„¸ë¡œ ë§µ ê¸°ì¤€)
        
        let localPlayer = {
            x: 100,
            y: 300,
            vx: 0,
            vy: 0,
            color: HAMSTER_COLORS[0],
            name: 'í–„ì°Œ',
            onGround: false,
            onButton: false,
            isDead: false,
            facing: 1,
            variant: 0
        };
        
        let players = {};
        let smoothedPlayers = {};
        // ë„¤íŠ¸ì›Œí¬ ë³´ê°„ìš© íˆìŠ¤í† ë¦¬ ë²„í¼ (ìƒëŒ€ ì›€ì§ì„ ëŠê¹€ ì™„í™”)
        let remoteHistory = {}; // { sid: [{t,x,y,vx,vy,isDead,color,name}, ...] }
        const NET_INTERP_DELAY_MS = 120; // ì•½ê°„ì˜ ì§€ì—°ì„ ë‘ê³  ë³´ê°„ (ì§€í„°/ëŠê¹€ ì™„í™”)
        const NET_MAX_HISTORY_MS = 2000;
        let gameObjects = [];
        let canvas, ctx;
        let cameraX = 0;
        let cameraY = 0;
        let stageBounds = { minX: 0, maxX: 1200, minY: 0, maxY: 1000 };
        let deathCount = 0; // í˜„ì¬ ë ˆë²¨ ì‚¬ë§ íšŸìˆ˜
        let gameRunning = false;
        let rafId = null;
        
        // í„°ì¹˜ ìƒíƒœ
        let touches = {};
        let moveDirection = 0; // -1: ì™¼ìª½, 0: ì •ì§€, 1: ì˜¤ë¥¸ìª½
        
        // ==================== ì‚¬ìš´ë“œ ì‹œìŠ¤í…œ ====================
        let audioCtx = null;

        // ë°°ê²½ìŒì•… (ì²¨ë¶€ mp3) - ê²Œì„ ì§„í–‰ ì¤‘ ë°˜ë³µ ì¬ìƒ
        let bgmEl = null;
        let bgmWanted = false;

        function initBGM() {
            if (!bgmEl) bgmEl = document.getElementById('bgm');
            if (bgmEl) {
                bgmEl.loop = true;
                bgmEl.preload = 'auto';
                // ê¸°ë³¸ ë³¼ë¥¨ (ë„ˆë¬´ í¬ì§€ ì•Šê²Œ)
                if (typeof bgmEl.volume === 'number') bgmEl.volume = 0.5;
            }
        }

        async function startBGM() {
            initBGM();
            if (!bgmEl) return;
            bgmWanted = true;
            try {
                await bgmEl.play();
            } catch (e) {
                // ìë™ì¬ìƒ ì œí•œ: ì²« ì…ë ¥ ì‹œ ì¬ì‹œë„
            }
        }

        function stopBGM() {
            bgmWanted = false;
            if (!bgmEl) return;
            try {
                bgmEl.pause();
                bgmEl.currentTime = 0;
            } catch (e) {}
        }

        // ì‚¬ìš©ì ì…ë ¥ì´ ë°œìƒí•˜ë©´ ì˜¤ë””ì˜¤ ì»¨í…ìŠ¤íŠ¸/ë°°ê²½ìŒì•… ì¬ì‹œë„ (ìë™ì¬ìƒ ì œí•œ ëŒ€ì‘)
        (function attachBGMGestureRetry(){
            const tryStart = async () => {
                initAudio();
                initBGM();
                if (!bgmEl) return;
                if (!bgmWanted) return;
                if (!bgmEl.paused) return;
                try { await bgmEl.play(); } catch (e) { return; }
            };
            document.addEventListener('pointerdown', tryStart, { passive: true });
            document.addEventListener('touchstart', tryStart, { passive: true });
            document.addEventListener('keydown', tryStart);
        })();
        
        function initAudio() {
            if (!audioCtx) {
                audioCtx = new (window.AudioContext || window.webkitAudioContext)();
            }
            if (audioCtx.state === 'suspended') {
                audioCtx.resume();
            }
        }
        
        function playTone(frequency, duration, type = 'square', volume = 0.3, slide = 0) {
            if (!audioCtx) return;
            
            const oscillator = audioCtx.createOscillator();
            const gainNode = audioCtx.createGain();
            
            oscillator.connect(gainNode);
            gainNode.connect(audioCtx.destination);
            
            oscillator.type = type;
            oscillator.frequency.setValueAtTime(frequency, audioCtx.currentTime);
            
            if (slide !== 0) {
                oscillator.frequency.linearRampToValueAtTime(frequency + slide, audioCtx.currentTime + duration);
            }
            
            gainNode.gain.setValueAtTime(volume, audioCtx.currentTime);
            gainNode.gain.exponentialRampToValueAtTime(0.01, audioCtx.currentTime + duration);
            
            oscillator.start(audioCtx.currentTime);
            oscillator.stop(audioCtx.currentTime + duration);
        }
        
        // ì í”„ ì†Œë¦¬ - ê·€ì—¬ìš´ "ë¿…!"
        function sfxJump() {
            initAudio();
            playTone(400, 0.1, 'sine', 0.2, 400);
        }
        
        // ë²„íŠ¼ ëˆ„ë¦„ - ë°ì€ "ë”©!"
        function sfxButton() {
            initAudio();
            playTone(880, 0.1, 'sine', 0.2);
            setTimeout(() => playTone(1100, 0.15, 'sine', 0.15), 50);
        }
        
        // ë¬¸ ì—´ë¦¼ - ìƒìŠ¹ ë©œë¡œë””
        function sfxDoorOpen() {
            initAudio();
            playTone(440, 0.1, 'triangle', 0.15);
            setTimeout(() => playTone(550, 0.1, 'triangle', 0.15), 80);
            setTimeout(() => playTone(660, 0.15, 'triangle', 0.15), 160);
        }
        
        // ì‚¬ë§ - ìŠ¬í”ˆ í•˜ê°•ìŒ
        function sfxDeath() {
            initAudio();
            playTone(400, 0.15, 'square', 0.2, -200);
            setTimeout(() => playTone(200, 0.3, 'square', 0.15, -100), 150);
        }
        
        // ë ˆë²¨ í´ë¦¬ì–´ - ì¶•í•˜ ë©œë¡œë””
        function sfxLevelClear() {
            initAudio();
            const notes = [523, 659, 784, 1047]; // C5, E5, G5, C6
            notes.forEach((note, i) => {
                setTimeout(() => playTone(note, 0.15, 'sine', 0.2), i * 100);
            });
        }
        
        // ê²Œì„ í´ë¦¬ì–´ - ê¸´ ì¶•í•˜ ë©œë¡œë””
        function sfxGameClear() {
            initAudio();
            const notes = [523, 587, 659, 698, 784, 880, 988, 1047]; // C major scale
            notes.forEach((note, i) => {
                setTimeout(() => playTone(note, 0.2, 'sine', 0.25), i * 120);
            });
            setTimeout(() => {
                playTone(1047, 0.4, 'sine', 0.3);
                playTone(1319, 0.4, 'sine', 0.2);
                playTone(1568, 0.4, 'sine', 0.2);
            }, notes.length * 120);
        }
        
        // ê±·ê¸° ì†Œë¦¬ (ì‘ì€ ë°œì†Œë¦¬)
        let lastStepTime = 0;
        function sfxStep() {
            const now = Date.now();
            if (now - lastStepTime < 200) return; // 200msë§ˆë‹¤ í•œ ë²ˆ
            lastStepTime = now;
            initAudio();
            playTone(100 + Math.random() * 50, 0.05, 'sine', 0.05);
        }
        
        // ë°•ìŠ¤ ë°€ê¸° ì†Œë¦¬
        let lastPushTime = 0;
        function sfxPush() {
            const now = Date.now();
            if (now - lastPushTime < 150) return;
            lastPushTime = now;
            initAudio();
            playTone(150, 0.08, 'square', 0.1);
        }
        
        
               // ==================== ëª¨ë°”ì¼ ì„¸ë¡œ ì§„í–‰ ë ˆë²¨ ====================
        // í•œ ì† í”Œë ˆì´ì—ì„œë„ ëª©ì ì§€ê°€ í™”ë©´ íë¦„(ìœ„/ì•„ë˜) ì•ˆì—ì„œ ìì—°ìŠ¤ëŸ½ê²Œ ë³´ì´ë„ë¡
        // ì¢ê³  ë†’ì€(ì„¸ë¡œ) ìŠ¤í…Œì´ì§€ë¡œ êµ¬ì„±.
                const LEVELS = [
            // 1) ê¸°ë³¸ ë“±ë°˜ (ì•ˆì „ ê°„ê²©)
            {
                spawn: { x: 120, y: 2320 },
                goal:  { x: 200, y: 120, width: 120, height: 80 },
                platforms: [
                    { x: 0,   y: 2400, width: 520, height: 70, color: '#2d3436' },

                    { x: 70,  y: 2230, width: 180, height: 20, color: '#636e72' },
                    { x: 270, y: 2070, width: 180, height: 20, color: '#636e72' },
                    { x: 80,  y: 1910, width: 180, height: 20, color: '#636e72' },
                    { x: 270, y: 1750, width: 180, height: 20, color: '#636e72' },
                    { x: 110, y: 1590, width: 220, height: 20, color: '#636e72' },
                    { x: 170, y: 1430, width: 220, height: 20, color: '#636e72' },
                    { x: 120, y: 1270, width: 260, height: 20, color: '#636e72' },
                    { x: 150, y: 1110, width: 220, height: 20, color: '#636e72' },
                    { x: 120, y:  950, width: 260, height: 20, color: '#636e72' },
                    { x: 150, y:  790, width: 220, height: 20, color: '#636e72' },
                    { x: 120, y:  630, width: 260, height: 20, color: '#636e72' },
                    { x: 150, y:  470, width: 220, height: 20, color: '#636e72' },
                    { x: 120, y:  310, width: 260, height: 20, color: '#636e72' },
                    { x: 140, y:  170, width: 240, height: 20, color: '#636e72' },
                ],
                buttons: [], doors: [], spikes: [], boxes: [], lifts: [], bridges: [],
                message: ""
            },

            // 2) ë¬¸(ë²½) + ë²„íŠ¼ (í˜¼ìë„ ë°•ìŠ¤ë¡œ ê°€ëŠ¥)
            {
                spawn: { x: 120, y: 2320 },
                goal:  { x: 210, y: 120, width: 110, height: 80 },
                platforms: [
                    { x: 0,   y: 2400, width: 520, height: 70, color: '#2d3436' },

                    // ë¬¸ ìœ„ë¡œ ì˜¬ë¼ê°€ê¸° ìœ„í•œ ë°œíŒë“¤ (ë¬¸ì´ ì—´ë ¤ì•¼ í†µê³¼)
                    { x: 80,  y: 2120, width: 200, height: 20, color: '#636e72' },
                    { x: 260, y: 1960, width: 200, height: 20, color: '#636e72' },
                    { x: 90,  y: 1800, width: 200, height: 20, color: '#636e72' },

                    { x: 140, y: 1560, width: 240, height: 20, color: '#636e72' },
                    { x: 140, y: 1400, width: 240, height: 20, color: '#636e72' },
                    { x: 140, y: 1240, width: 240, height: 20, color: '#636e72' },
                    { x: 140, y: 1080, width: 240, height: 20, color: '#636e72' },
                    { x: 140, y:  920, width: 240, height: 20, color: '#636e72' },
                    { x: 140, y:  760, width: 240, height: 20, color: '#636e72' },
                    { x: 140, y:  600, width: 240, height: 20, color: '#636e72' },
                    { x: 140, y:  440, width: 240, height: 20, color: '#636e72' },
                    { x: 140, y:  280, width: 240, height: 20, color: '#636e72' },
                ],
                doors: [
                    // ë‹«íˆë©´ ìœ„ë¡œ ëª» ì˜¬ë¼ê°€ê²Œ ë§‰ëŠ” ê°€ë¡œ ë²½
                    { x: 0, y: 1680, width: 520, height: 30, open: false }
                ],
                buttons: [
                    { x: 60, y: 2388, width: 70, height: 12, pressed: false, doorId: 0 }
                ],
                boxes: [
                    { x: 170, y: 2340, width: 40, height: 40, color: '#b2bec3' }
                ],
                spikes: [], lifts: [], bridges: [],
                message: ""
            },

            // 3) ë‹¤ë¦¬ ìƒì„±(ë¸Œë¦¿ì§€) + ë²„íŠ¼ (ë°•ìŠ¤ë¡œ ê³ ì •)
            {
                spawn: { x: 120, y: 2320 },
                goal:  { x: 210, y: 120, width: 110, height: 80 },
                platforms: [
                    { x: 0,   y: 2400, width: 520, height: 70, color: '#2d3436' },

                    { x: 70,  y: 2210, width: 180, height: 20, color: '#636e72' },
                    { x: 270, y: 2050, width: 180, height: 20, color: '#636e72' },

                    // í° ê°­(ê°€ìš´ë° ë‹¤ë¦¬ í•„ìš”)
                    { x: 60,  y: 1760, width: 160, height: 20, color: '#636e72' },
                    { x: 300, y: 1760, width: 160, height: 20, color: '#636e72' },

                    { x: 140, y: 1480, width: 240, height: 20, color: '#636e72' },
                    { x: 140, y: 1320, width: 240, height: 20, color: '#636e72' },
                    { x: 140, y: 1160, width: 240, height: 20, color: '#636e72' },
                    { x: 140, y: 1000, width: 240, height: 20, color: '#636e72' },
                    { x: 140, y:  840, width: 240, height: 20, color: '#636e72' },
                    { x: 140, y:  680, width: 240, height: 20, color: '#636e72' },
                    { x: 140, y:  520, width: 240, height: 20, color: '#636e72' },
                    { x: 140, y:  360, width: 240, height: 20, color: '#636e72' },
                    { x: 140, y:  200, width: 240, height: 20, color: '#636e72' },
                ],
                bridges: [
                    { x: 210, y: 1760, width: 100, height: 20, color: '#00cec9', active: false }
                ],
                buttons: [
                    { x: 60, y: 2200, width: 70, height: 12, pressed: false, bridgeId: 0 }
                ],
                boxes: [
                    { x: 160, y: 2340, width: 40, height: 40, color: '#b2bec3' }
                ],
                doors: [], spikes: [], lifts: [],
                message: ""
            },

            // 4) ë¦¬í”„íŠ¸(ë²„íŠ¼ì„ ëˆ„ë¥´ê³  íƒ€ê¸°) (ë°•ìŠ¤ë¡œ ê³ ì • ê°€ëŠ¥)
            {
                spawn: { x: 120, y: 2320 },
                goal:  { x: 210, y: 120, width: 110, height: 80 },
                platforms: [
                    { x: 0,   y: 2400, width: 520, height: 70, color: '#2d3436' },

                    // ë¦¬í”„íŠ¸ ì—†ì´ ëª» ì˜¬ë¼ê°€ê²Œ ë²½ í˜•íƒœ
                    { x: 60,  y: 2060, width: 180, height: 20, color: '#636e72' },
                    { x: 280, y: 1900, width: 180, height: 20, color: '#636e72' },
                    { x: 140, y: 1640, width: 240, height: 20, color: '#636e72' },

                    { x: 140, y: 1480, width: 240, height: 20, color: '#636e72' },
                    { x: 140, y: 1320, width: 240, height: 20, color: '#636e72' },
                    { x: 140, y: 1160, width: 240, height: 20, color: '#636e72' },
                    { x: 140, y: 1000, width: 240, height: 20, color: '#636e72' },
                    { x: 140, y:  840, width: 240, height: 20, color: '#636e72' },
                    { x: 140, y:  680, width: 240, height: 20, color: '#636e72' },
                    { x: 140, y:  520, width: 240, height: 20, color: '#636e72' },
                    { x: 140, y:  360, width: 240, height: 20, color: '#636e72' },
                    { x: 140, y:  200, width: 240, height: 20, color: '#636e72' },
                ],
                lifts: [
                    { x: 340, y: 2340, width: 120, height: 20, minY: 1800, maxY: 2340, speed: 3.0, color: '#6c5ce7' }
                ],
                buttons: [
                    { x: 60, y: 2388, width: 70, height: 12, pressed: false, liftId: 0 }
                ],
                boxes: [
                    { x: 170, y: 2340, width: 40, height: 40, color: '#b2bec3' }
                ],
                doors: [], spikes: [], bridges: [],
                message: ""
            },

            // 5) ë¬¸ + ë‹¤ë¦¬ 2ë‹¨ê³„ (ë°•ìŠ¤ 2ê°œ)
            {
                spawn: { x: 120, y: 2320 },
                goal:  { x: 210, y: 120, width: 110, height: 80 },
                platforms: [
                    { x: 0,   y: 2400, width: 520, height: 70, color: '#2d3436' },

                    { x: 70,  y: 2210, width: 180, height: 20, color: '#636e72' },
                    { x: 270, y: 2050, width: 180, height: 20, color: '#636e72' },

                    // ê°­: ë¸Œë¦¿ì§€ í•„ìš”
                    { x: 60,  y: 1760, width: 160, height: 20, color: '#636e72' },
                    { x: 300, y: 1760, width: 160, height: 20, color: '#636e72' },

                    // ë¬¸ ìœ„ë¡œ ê°€ëŠ” í†µë¡œ
                    { x: 140, y: 1500, width: 240, height: 20, color: '#636e72' },
                    { x: 140, y: 1340, width: 240, height: 20, color: '#636e72' },
                    { x: 140, y: 1180, width: 240, height: 20, color: '#636e72' },
                    { x: 140, y: 1020, width: 240, height: 20, color: '#636e72' },
                    { x: 140, y:  860, width: 240, height: 20, color: '#636e72' },
                    { x: 140, y:  700, width: 240, height: 20, color: '#636e72' },
                    { x: 140, y:  540, width: 240, height: 20, color: '#636e72' },
                    { x: 140, y:  380, width: 240, height: 20, color: '#636e72' },
                    { x: 140, y:  220, width: 240, height: 20, color: '#636e72' },
                ],
                bridges: [
                    { x: 210, y: 1760, width: 100, height: 20, color: '#00cec9', active: false }
                ],
                doors: [
                    { x: 0, y: 1420, width: 520, height: 30, open: false }
                ],
                buttons: [
                    // ë¸Œë¦¿ì§€ ë²„íŠ¼(ì•„ë˜): ë°•ìŠ¤ë¡œ ê³ ì •
                    { x: 60, y: 2200, width: 70, height: 12, pressed: false, bridgeId: 0 },
                    // ë¬¸ ë²„íŠ¼(ì¤‘ê°„): ê·¼ì²˜ ë°•ìŠ¤ë¡œ ê³ ì •
                    { x: 360, y: 1490, width: 70, height: 12, pressed: false, doorId: 0 }
                ],
                boxes: [
                    { x: 160, y: 2340, width: 40, height: 40, color: '#b2bec3' },
                    { x: 320, y: 1460, width: 40, height: 40, color: '#b2bec3' },
                ],
                spikes: [], lifts: [],
                message: ""
            },

            // 6) ìŠ¤íŒŒì´í¬ íšŒí”¼ (ê°„ê²©/ë‚œì´ë„ í•©ë¦¬í™”)
            {
                spawn: { x: 120, y: 2320 },
                goal:  { x: 210, y: 120, width: 110, height: 80 },
                platforms: [
                    { x: 0,   y: 2400, width: 520, height: 70, color: '#2d3436' },

                    { x: 80,  y: 2230, width: 170, height: 20, color: '#636e72' },
                    { x: 270, y: 2070, width: 170, height: 20, color: '#636e72' },

                    // ìŠ¤íŒŒì´í¬ êµ¬ê°„ ìœ„/ì•„ë˜ë¡œ ìš°íšŒ
                    { x: 60,  y: 1910, width: 160, height: 20, color: '#636e72' },
                    { x: 300, y: 1910, width: 160, height: 20, color: '#636e72' },

                    { x: 140, y: 1650, width: 240, height: 20, color: '#636e72' },
                    { x: 140, y: 1490, width: 240, height: 20, color: '#636e72' },
                    { x: 140, y: 1330, width: 240, height: 20, color: '#636e72' },
                    { x: 140, y: 1170, width: 240, height: 20, color: '#636e72' },
                    { x: 140, y: 1010, width: 240, height: 20, color: '#636e72' },
                    { x: 140, y:  850, width: 240, height: 20, color: '#636e72' },
                    { x: 140, y:  690, width: 240, height: 20, color: '#636e72' },
                    { x: 140, y:  530, width: 240, height: 20, color: '#636e72' },
                    { x: 140, y:  370, width: 240, height: 20, color: '#636e72' },
                    { x: 140, y:  210, width: 240, height: 20, color: '#636e72' },
                ],
                spikes: [
                    { x: 160, y: 2360, width: 200, height: 40 },
                    { x: 160, y: 1870, width: 200, height: 40 },
                ],
                doors: [], buttons: [], boxes: [], lifts: [], bridges: [],
                message: ""
            },

            // 7) ë°•ìŠ¤ë¥¼ ë°œíŒì²˜ëŸ¼ ì¨ì„œ ì˜¬ë¼ê°€ê¸°
            {
                spawn: { x: 120, y: 2320 },
                goal:  { x: 210, y: 120, width: 110, height: 80 },
                platforms: [
                    { x: 0,   y: 2400, width: 520, height: 70, color: '#2d3436' },

                    // ì²« ë°œíŒì€ ë‚®ê²Œ
                    { x: 80,  y: 2230, width: 220, height: 20, color: '#636e72' },

                    // ë‹¤ìŒ ë°œíŒì´ ì‚´ì§ ë†’ì•„ì„œ ë°•ìŠ¤ ì í”„ê°€ ë„ì›€ë¨
                    { x: 300, y: 1960, width: 160, height: 20, color: '#636e72' },

                    { x: 140, y: 1700, width: 240, height: 20, color: '#636e72' },
                    { x: 140, y: 1540, width: 240, height: 20, color: '#636e72' },
                    { x: 140, y: 1380, width: 240, height: 20, color: '#636e72' },
                    { x: 140, y: 1220, width: 240, height: 20, color: '#636e72' },
                    { x: 140, y: 1060, width: 240, height: 20, color: '#636e72' },
                    { x: 140, y:  900, width: 240, height: 20, color: '#636e72' },
                    { x: 140, y:  740, width: 240, height: 20, color: '#636e72' },
                    { x: 140, y:  580, width: 240, height: 20, color: '#636e72' },
                    { x: 140, y:  420, width: 240, height: 20, color: '#636e72' },
                    { x: 140, y:  260, width: 240, height: 20, color: '#636e72' },
                ],
                boxes: [
                    { x: 150, y: 2340, width: 40, height: 40, color: '#b2bec3' }
                ],
                doors: [], buttons: [], spikes: [], lifts: [], bridges: [],
                message: ""
            },

            // 8) ìµœì¢…: ë¦¬í”„íŠ¸ + ë¸Œë¦¿ì§€ ì—°ê³„ (ë°•ìŠ¤ 2ê°œë¡œ ê³ ì •)
            {
                spawn: { x: 120, y: 2320 },
                goal:  { x: 210, y: 90, width: 110, height: 90 },
                platforms: [
                    { x: 0,   y: 2400, width: 520, height: 70, color: '#2d3436' },

                    { x: 70,  y: 2210, width: 180, height: 20, color: '#636e72' },
                    { x: 270, y: 2050, width: 180, height: 20, color: '#636e72' },

                    // ì¤‘ê°„ì¸µ ê°­(ë¸Œë¦¿ì§€ë¡œ ì—°ê²°)
                    { x: 60,  y: 1700, width: 160, height: 20, color: '#636e72' },
                    { x: 300, y: 1700, width: 160, height: 20, color: '#636e72' },

                    { x: 140, y: 1440, width: 240, height: 20, color: '#636e72' },
                    { x: 140, y: 1280, width: 240, height: 20, color: '#636e72' },
                    { x: 140, y: 1120, width: 240, height: 20, color: '#636e72' },
                    { x: 140, y:  960, width: 240, height: 20, color: '#636e72' },
                    { x: 140, y:  800, width: 240, height: 20, color: '#636e72' },
                    { x: 140, y:  640, width: 240, height: 20, color: '#636e72' },
                    { x: 140, y:  480, width: 240, height: 20, color: '#636e72' },
                    { x: 140, y:  320, width: 240, height: 20, color: '#636e72' },
                    { x: 140, y:  160, width: 240, height: 20, color: '#636e72' },
                ],
                lifts: [
                    { x: 360, y: 2340, width: 120, height: 20, minY: 1860, maxY: 2340, speed: 3.2, color: '#6c5ce7' }
                ],
                bridges: [
                    { x: 210, y: 1700, width: 100, height: 20, color: '#00cec9', active: false }
                ],
                buttons: [
                    { x: 60, y: 2388, width: 70, height: 12, pressed: false, liftId: 0 },
                    { x: 360, y: 2040, width: 70, height: 12, pressed: false, bridgeId: 0 }
                ],
                boxes: [
                    { x: 170, y: 2340, width: 40, height: 40, color: '#b2bec3' },
                    { x: 420, y: 2000, width: 40, height: 40, color: '#b2bec3' },
                ],
                doors: [], spikes: [],
                message: ""
            },
        ];
        // ==================== ì—ëŸ¬ í‘œì‹œ ====================
        function showError(msg, isError = true) {
            const el = document.getElementById('errorMsg');
            el.textContent = msg;
            el.className = 'error-msg show';
            el.style.color = isError ? '#ff6b6b' : '#00b894';
            el.style.background = isError ? 'rgba(255,107,107,0.2)' : 'rgba(0,184,148,0.2)';
            setTimeout(() => el.classList.remove('show'), 3000);
        }
        
        // ==================== ë°© ê´€ë¦¬ ====================
        function generateRoomCode() {
            const chars = 'ABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789';
            let code = '';
            for (let i = 0; i < 5; i++) {
                code += chars.charAt(Math.floor(Math.random() * chars.length));
            }
            return code;
        }

        // ==================== ì„ë² ë“œ ëª¨ë“œ(Colyseus ë¸Œë¦¿ì§€) ====================
        function startEmbedded(init){
            isGuestMode = !!init.practice || EMBED_PRACTICE;
            isHost = !!init.isHost;
            roomId = String(init.roomCode || 'ROOM');
            playerId = String(init.sessionId || ('p_' + Date.now()));
            localPlayer.name = String(init.nick || 'í–„ì°Œ').slice(0, 16);
            const seat = typeof init.seat === 'number' ? init.seat : 0;
            localPlayer.color = HAMSTER_COLORS[seat % HAMSTER_COLORS.length];
            localPlayer.variant = seat % 4;
            currentLevel = 1;
            try{ tgEnded = false; }catch(e){}
            startGame();
            // ì²« ìƒíƒœ ì „ì†¡
            bridgeSendState(true);
        }

        // createRoom()/joinRoom()/Firebase ë¡œì§ ì œê±°: ì™¸ë¶€ ë¡œë¹„(Colyseus)ì—ì„œ ë°©/ì…ì¥ì„ ì²˜ë¦¬í•©ë‹ˆë‹¤.
        
        function startGuestMode() {
            const name = document.getElementById('playerName').value.trim() || 'í–„ì°Œ';
            
            isGuestMode = true;
            isHost = true;
            roomId = 'GUEST';
            playerId = 'guest_player';
            
            localPlayer.name = name;
            localPlayer.color = HAMSTER_COLORS[0];
            localPlayer.variant = 0;
            localPlayer.x = LEVELS[0].spawn.x;
            localPlayer.y = LEVELS[0].spawn.y;
            
            startGame();
        }
        
        function updatePlayerList() {
            const container = document.getElementById('playerList');
            let html = `<div class="player-item">
                <div class="player-dot" style="background:${localPlayer.color}"></div>
                <span>${localPlayer.name} ${isGuestMode ? '(ì—°ìŠµì¤‘)' : '(ë‚˜)'}</span>
            </div>`;
            
            if (!isGuestMode) {
                Object.values(players).forEach(p => {
                    html += `<div class="player-item">
                        <div class="player-dot" style="background:${p.color}"></div>
                        <span>${p.name}</span>
                    </div>`;
                });
            }
            
            container.innerHTML = html;
        }
        
        // ==================== ê²Œì„ ì‹œì‘ ====================
        function startGame() {
            document.getElementById('lobby').classList.add('hidden');
            document.getElementById('gameContainer').style.display = 'flex';
            document.getElementById('displayRoomCode').textContent = isGuestMode ? 'ì—°ìŠµ' : ('ë°©: ' + roomId);
            
            canvas = document.getElementById('gameCanvas');
            ctx = canvas.getContext('2d');
            
            // ì˜¤ë””ì˜¤ ì´ˆê¸°í™”
            initAudio();
            // ë°°ê²½ìŒì•… ì‹œì‘ (ìë™ì¬ìƒ ì œí•œ ì‹œ ì²« ì…ë ¥ì—ì„œ ì¬ì‹œë„)
            startBGM();
            
            resizeCanvas();
            window.addEventListener('resize', resizeCanvas);
            
            loadLevel(currentLevel);
            setupControls();
            updatePlayerList();
            
            // ë‚˜ê°€ê¸° ë²„íŠ¼
            const exitBtn = document.getElementById('exitBtn');
            if (exitBtn && !exitBtn._bound){
                exitBtn._bound = true;
                exitBtn.addEventListener('click', ()=>{
                    // ì„ë² ë“œ(ë°© ì•ˆ ì—°ìŠµ í¬í•¨): ë¶€ëª¨ì—ê²Œ ë‚˜ê°€ê¸° ì‹ í˜¸ë§Œ ë³´ëƒ„
                    if (EMBED){
                        try{ bridgeSend("tg_quit", { practice: !!isGuestMode }); }catch(e){}
                        try{ stopBGM(); }catch(e){}
                        gameRunning = false;
                        if (rafId) { try{ cancelAnimationFrame(rafId); }catch(e){} rafId = null; }
                        return;
                    }

                    // ë‹¨ë…/ì—°ìŠµ ëª¨ë“œëŠ” ì•ˆì „í•˜ê²Œ ìƒˆë¡œê³ ì¹¨(ì¤‘ë³µ ë¦¬ìŠ¤ë„ˆ ë°©ì§€)
                    try{ stopBGM(); }catch(e){}
                    location.reload();
                });
            }

            // ë£¨í”„ ì‹œì‘
            gameRunning = true;
            gameLoop();
        }
        
        function resizeCanvas() {
            canvas.width = window.innerWidth;
            canvas.height = window.innerHeight;
        }

        // ==================== ë ˆë²¨ ì•ˆì „ì¥ì¹˜ ====================
        // ì í”„ ë†’ì´ë¥¼ ë‚®ì¶˜ ìƒíƒœì—ì„œ "ë¬¸(ë²½)" ë’¤ìª½ì— ë²„íŠ¼ì´ ìˆì–´ ì•„ì˜ˆ ëª» ëˆ„ë¥´ëŠ” ìƒí™©ì„ ë°©ì§€í•œë‹¤.
        // - ìŠ¤í° ìœ„ì¹˜ ê¸°ì¤€ìœ¼ë¡œ ë¬¸ê³¼ ê°™ì€ í¸ì— ë²„íŠ¼ì´ í•˜ë‚˜ë„ ì—†ìœ¼ë©´,
        //   ìŠ¤í° ê·¼ì²˜ì— 2ì¸µ(ì‘ì€ ë°œíŒ 2ê°œ) + ë²„íŠ¼ì„ ì¶”ê°€ë¡œ ìƒì„±í•´ì„œ ì§„í–‰ ë¶ˆê°€ ìƒíƒœë¥¼ ì œê±°.
        function findGroundYAt(x) {
            // í•´ë‹¹ x ì•„ë˜ì—ì„œ ê°€ì¥ "ë‚®ì€"(yê°€ í°) í”Œë«í¼ yë¥¼ ì°¾ëŠ”ë‹¤.
            let groundY = null;
            for (const p of (gameObjects?.platforms || [])) {
                if (x >= p.x && x <= p.x + p.width) {
                    if (groundY === null || p.y > groundY) groundY = p.y;
                }
            }
            return (groundY === null) ? 400 : groundY;
        }

        function stageMaxX() {
            let mx = 1200;
            const objs = gameObjects || {};
            (objs.platforms || []).forEach(p => mx = Math.max(mx, p.x + p.width));
            (objs.doors || []).forEach(d => mx = Math.max(mx, d.x + d.width));
            if (objs.goal) mx = Math.max(mx, objs.goal.x + (objs.goal.width || 0));
            return mx;
        }

        function clamp(v, min, max) {
            if (max < min) return min;
            return Math.max(min, Math.min(v, max));
        }

        function computeStageBounds() {
            let minX = Infinity, minY = Infinity, maxX = -Infinity, maxY = -Infinity;
            const objs = gameObjects || {};

            const pushRect = (r) => {
                if (!r) return;
                const x = (typeof r.x === 'number') ? r.x : 0;
                const y = (typeof r.y === 'number') ? r.y : 0;
                const w = (typeof r.width === 'number') ? r.width : 0;
                const h = (typeof r.height === 'number') ? r.height : 0;
                minX = Math.min(minX, x);
                minY = Math.min(minY, y);
                maxX = Math.max(maxX, x + w);
                maxY = Math.max(maxY, y + h);
            };

            (objs.platforms || []).forEach(pushRect);
            (objs.doors || []).forEach(pushRect);
            (objs.buttons || []).forEach(pushRect);
            (objs.spikes || []).forEach(pushRect);
            (objs.boxes || []).forEach(pushRect);
            (objs.bridges || []).forEach(pushRect);

            // ë¦¬í”„íŠ¸ëŠ” ì´ë™ ë²”ìœ„ë¥¼ í¬í•¨
            (objs.lifts || []).forEach(l => {
                const x = (typeof l.x === 'number') ? l.x : 0;
                const w = (typeof l.width === 'number') ? l.width : 0;
                const h = (typeof l.height === 'number') ? l.height : 0;
                const y0 = (typeof l.y === 'number') ? l.y : 0;
                const minYv = (typeof l.minY === 'number') ? l.minY : y0;
                const maxYv = (typeof l.maxY === 'number') ? l.maxY : y0;
                pushRect({ x, y: Math.min(minYv, maxYv), width: w, height: Math.abs(maxYv - minYv) + h });
            });

            if (objs.goal) pushRect(objs.goal);

            if (!isFinite(minX) || !isFinite(minY) || !isFinite(maxX) || !isFinite(maxY)) {
                stageBounds = { minX: 0, maxX: 1200, minY: 0, maxY: 1000 };
                return stageBounds;
            }

            // íŒ¨ë”©
            const padX = 180;
            const padY = 220;
            minX = Math.max(0, minX - padX);
            minY = Math.max(0, minY - padY);
            maxX = maxX + padX;
            maxY = maxY + padY;

            stageBounds = { minX, maxX, minY, maxY };
            return stageBounds;
        }


        function ensureDoorButtonsAccessible(level) {
            if (!gameObjects?.doors || !gameObjects?.buttons) return;

            const spawnX = level.spawn.x;
            const mx = stageMaxX();

            gameObjects.doors.forEach((door, doorId) => {
                // í•´ë‹¹ doorIdë¥¼ ì œì–´í•˜ëŠ” ë²„íŠ¼ì´ ìˆëŠ” ê²½ìš°ë§Œ
                const related = gameObjects.buttons.filter(b => b.doorId === doorId);
                if (related.length === 0) return;

                const needLeft = spawnX < door.x;
                const needRight = spawnX > (door.x + door.width);
                if (!needLeft && !needRight) return;

                if (needLeft) {
                    const hasLeft = related.some(b => (b.x + b.width) <= (door.x - 5));
                    if (hasLeft) return;
                    addFallbackDoorButton(level, door, doorId, 'left', mx);
                } else if (needRight) {
                    const hasRight = related.some(b => b.x >= (door.x + door.width + 5));
                    if (hasRight) return;
                    addFallbackDoorButton(level, door, doorId, 'right', mx);
                }
            });
        }

        function addFallbackDoorButton(level, door, doorId, side, mx) {
            const groundY = findGroundYAt(level.spawn.x);
            const step = 70; // ì í”„(2/3) ê¸°ì¤€ìœ¼ë¡œ ì•ˆì •ì ìœ¼ë¡œ ì˜¤ë¥¼ ìˆ˜ ìˆëŠ” ë†’ì´
            const midY = Math.max(80, groundY - step);
            const topY = Math.max(60, groundY - step * 2);

            // ìŠ¤í° ê·¼ì²˜ì— ì‘ì€ 2ì¸µ ë°œíŒì„ ë§Œë“¤ê³  ìœ„ì¸µì— ë²„íŠ¼ ë°°ì¹˜
            let baseX;
            if (side === 'left') {
                baseX = level.spawn.x + 110;
                baseX = Math.min(baseX, door.x - 220);
                baseX = Math.max(30, baseX);
            } else {
                baseX = level.spawn.x - 250;
                baseX = Math.max(baseX, door.x + door.width + 60);
                baseX = Math.min(mx - 200, baseX);
            }

            // ë°œíŒ ì¶”ê°€ (ì¤‘ë³µ ìƒì„± ë°©ì§€: ê°™ì€ doorId fallbackì´ ì´ë¯¸ ìˆìœ¼ë©´ skip)
            if (gameObjects.buttons.some(b => b.doorId === doorId && b.fallback)) return;

            gameObjects.platforms.push(
                { x: baseX, y: midY, width: 150, height: 20, color: '#636e72' },
                { x: baseX + 20, y: topY, width: 120, height: 20, color: '#636e72' }
            );

            gameObjects.buttons.push({
                x: baseX + 50,
                y: topY - 20,
                width: 60,
                height: 20,
                color: door.color || '#e17055',
                doorId,
                pressed: false,
                fallback: true
            });
        }
        
        function loadLevel(levelNum) {
            const level = LEVELS[levelNum - 1];
            if (!level) {
                // ëª¨ë“  ë ˆë²¨ í´ë¦¬ì–´
                document.getElementById('winScreen').querySelector('.win-text').textContent = 'ğŸŠ ê²Œì„ í´ë¦¬ì–´! ğŸŠ';
                document.getElementById('autoNextHint').style.display = 'none';
                document.getElementById('winScreen').classList.add('show');
                sfxGameClear();
                // ë©€í‹° ì„ë² ë“œ: ì„±ê³µ -> ë¶€ëª¨/ì„œë²„ë¡œ ê²°ê³¼ ì „ì†¡ (ìë™ ëŒ€ê¸°ì‹¤ ë³µê·€)
                bridgeSendOver(true, "game_clear");
                return;
            }
            
            document.getElementById('autoNextHint').style.display = 'block';
            document.getElementById('winScreen').querySelector('.win-text').textContent = 'ğŸ‰ ë ˆë²¨ í´ë¦¬ì–´! ğŸ‰';
            const label = isGuestMode ? `ì—°ìŠµ Â· ë ˆë²¨ ${levelNum}` : `ë ˆë²¨ ${levelNum}`;
            document.getElementById('levelInfo').textContent = label;
            document.getElementById('winScreen').classList.remove('show');
            levelClearLock = false;
            
            // ê²Œì„ ì˜¤ë¸Œì íŠ¸ ì´ˆê¸°í™”
            gameObjects = {
                platforms: [...level.platforms],
                buttons: level.buttons.map(b => ({...b, pressed: false})),
                doors: level.doors.map(d => ({...d, open: false})),
                spikes: [...level.spikes],
                goal: {...level.goal},
                boxes: (level.boxes || []).map(b => ({...b, vx: 0, vy: 0})),
                lifts: (level.lifts || []).map(l => ({...l, y: (typeof l.y === 'number') ? l.y : (typeof l.maxY === 'number' ? l.maxY : 0)})),
                bridges: (level.bridges || []).map(b => ({...b, active: false}))
            };

            // ë²„íŠ¼ì´ ë¬¸ ë°˜ëŒ€í¸ì— ìˆì–´ ì§„í–‰ ë¶ˆê°€ê°€ ë˜ëŠ” ë ˆë²¨ ìë™ ë³´ì •
            ensureDoorButtonsAccessible(level);
            computeStageBounds();
            
            // í”Œë ˆì´ì–´ ìœ„ì¹˜ ì´ˆê¸°í™”
            const colorIndex = HAMSTER_COLORS.indexOf(localPlayer.color);
            localPlayer.x = level.spawn.x + (colorIndex * 50);
            localPlayer.y = level.spawn.y;
            localPlayer.vx = 0;
            localPlayer.vy = 0;
            localPlayer.isDead = false;
            
            // ë„¤íŠ¸ì›Œí¬(ë¸Œë¦¿ì§€)ë¡œ ì´ˆê¸° ìœ„ì¹˜ ì „ì†¡
            bridgeSendState(true);

cameraX = 0;
            cameraY = 0;
        }
        
        function nextLevel() {
            if (isGuestMode) {
                currentLevel++;
                loadLevel(currentLevel);
                return;
            }

            const next = currentLevel + 1;

            // ì„ë² ë“œ ë©€í‹°: ëˆ„ê°€ ìš”ì²­í•´ë„ ì„œë²„ê°€ ë¸Œë¡œë“œìºìŠ¤íŠ¸ë¡œ ë™ê¸°í™”
            if (EMBED) {
                bridgeSend("tg_level", { level: next });
                return;
            }

            // ë¡œì»¬(ë¹„ì„ë² ë“œ) ëª¨ë“œ: ê¸°ì¡´ì²˜ëŸ¼ í˜¸ìŠ¤íŠ¸ë§Œ ì§„í–‰
            if (isHost) {
                currentLevel++;
                loadLevel(currentLevel);
            }
        }
        
        // ==================== í„°ì¹˜ ì»¨íŠ¸ë¡¤ ====================
        function setupControls() {
            // í„°ì¹˜ ì‹œì‘
            canvas.addEventListener('touchstart', (e) => {
                e.preventDefault();
                
                for (let touch of e.changedTouches) {
                    touches[touch.identifier] = {
                        x: touch.clientX,
                        y: touch.clientY,
                        startX: touch.clientX
                    };
                }
                
                // ë‘ ê°œ ì´ìƒ í„°ì¹˜ = ì í”„
                if (Object.keys(touches).length >= 2) {
                    if (localPlayer.onGround) {
                        localPlayer.vy = JUMP_VELOCITY;
                        localPlayer.onGround = false;
                        sfxJump();
                    }
                } else {
                    // ë‹¨ì¼ í„°ì¹˜ = ì´ë™ ë°©í–¥ ê²°ì •
                    updateMoveDirection();
                }
            });
            
            // í„°ì¹˜ ì´ë™
            canvas.addEventListener('touchmove', (e) => {
                e.preventDefault();
                
                for (let touch of e.changedTouches) {
                    if (touches[touch.identifier]) {
                        touches[touch.identifier].x = touch.clientX;
                        touches[touch.identifier].y = touch.clientY;
                    }
                }
                
                if (Object.keys(touches).length === 1) {
                    updateMoveDirection();
                }
            });
            
            // í„°ì¹˜ ì¢…ë£Œ
            canvas.addEventListener('touchend', (e) => {
                e.preventDefault();
                
                for (let touch of e.changedTouches) {
                    delete touches[touch.identifier];
                }
                
                if (Object.keys(touches).length === 0) {
                    moveDirection = 0;
                } else if (Object.keys(touches).length === 1) {
                    updateMoveDirection();
                }
            });
            
            canvas.addEventListener('touchcancel', (e) => {
                e.preventDefault();
                for (let touch of e.changedTouches) {
                    delete touches[touch.identifier];
                }
                if (Object.keys(touches).length === 0) {
                    moveDirection = 0;
                }
            });
            
            // ë§ˆìš°ìŠ¤ ì»¨íŠ¸ë¡¤ (ë°ìŠ¤í¬í†±) - í„°ì¹˜ì™€ ì™„ì „íˆ ë™ì¼í•œ ë°©ì‹
            // ì¢Œí´ë¦­ = ì†ê°€ë½1, ìš°í´ë¦­ = ì†ê°€ë½2
            canvas.addEventListener('mousedown', (e) => {
                e.preventDefault();
                initAudio();
                
                if (e.button === 0) { // ì™¼ìª½ í´ë¦­ = ì†ê°€ë½ 1
                    touches['mouseLeft'] = { x: e.clientX, y: e.clientY };
                } else if (e.button === 2) { // ì˜¤ë¥¸ìª½ í´ë¦­ = ì†ê°€ë½ 2
                    touches['mouseRight'] = { x: e.clientX, y: e.clientY };
                }
                
                // ë‘ ê°œ ì´ìƒ = ì í”„ (í„°ì¹˜ì™€ ë™ì¼)
                if (Object.keys(touches).length >= 2) {
                    if (localPlayer.onGround) {
                        localPlayer.vy = JUMP_VELOCITY;
                        localPlayer.onGround = false;
                        sfxJump();
                    }
                } else {
                    updateMoveDirection();
                }
            });
            
            canvas.addEventListener('mousemove', (e) => {
                if (touches['mouseLeft']) {
                    touches['mouseLeft'] = { x: e.clientX, y: e.clientY };
                }
                if (touches['mouseRight']) {
                    touches['mouseRight'] = { x: e.clientX, y: e.clientY };
                }
                
                if (Object.keys(touches).length === 1) {
                    updateMoveDirection();
                }
            });
            
            canvas.addEventListener('mouseup', (e) => {
                if (e.button === 0) {
                    delete touches['mouseLeft'];
                } else if (e.button === 2) {
                    delete touches['mouseRight'];
                }
                
                if (Object.keys(touches).length === 0) {
                    moveDirection = 0;
                } else if (Object.keys(touches).length === 1) {
                    updateMoveDirection();
                }
            });
            
            canvas.addEventListener('mouseleave', () => {
                delete touches['mouseLeft'];
                delete touches['mouseRight'];
                moveDirection = 0;
            });
            
            // ìš°í´ë¦­ ë©”ë‰´ ë¹„í™œì„±í™”
            canvas.addEventListener('contextmenu', (e) => {
                e.preventDefault();
            });
            
            // í‚¤ë³´ë“œ ì»¨íŠ¸ë¡¤ë„ ìœ ì§€ (ì„ íƒì  ì‚¬ìš©)
            document.addEventListener('keydown', (e) => {
                if (e.key === 'ArrowLeft' || e.key === 'a') moveDirection = -1;
                if (e.key === 'ArrowRight' || e.key === 'd') moveDirection = 1;
                if ((e.key === 'ArrowUp' || e.key === 'w' || e.key === ' ') && localPlayer.onGround) {
                    localPlayer.vy = JUMP_VELOCITY;
                    localPlayer.onGround = false;
                    sfxJump();
                }
            });
            
            document.addEventListener('keyup', (e) => {
                if ((e.key === 'ArrowLeft' || e.key === 'a') && moveDirection === -1) moveDirection = 0;
                if ((e.key === 'ArrowRight' || e.key === 'd') && moveDirection === 1) moveDirection = 0;
            });
        }
        
        function updateMoveDirection() {
            const touchList = Object.values(touches);
            if (touchList.length === 0) {
                moveDirection = 0;
                return;
            }
            
            const touch = touchList[0];
            const screenCenter = window.innerWidth / 2;
            
            // í™”ë©´ ì¤‘ì•™ ê¸°ì¤€ìœ¼ë¡œ ë°©í–¥ ê²°ì •
            if (touch.x < screenCenter) {
                moveDirection = -1;
            } else {
                moveDirection = 1;
            }
        }
        
        // ==================== ê²Œì„ ë¬¼ë¦¬ ====================
        function updatePhysics() {
            // ê¸°ë¯¹ ì—…ë°ì´íŠ¸ (ë¦¬í”„íŠ¸/ë‹¤ë¦¬)
            updateLifts();
            updateBridges();
            // ì´ë™
            const speed = 5;
            localPlayer.vx = moveDirection * speed;
            if (moveDirection !== 0) localPlayer.facing = moveDirection < 0 ? -1 : 1;
            
            // ê±·ê¸° íš¨ê³¼ìŒ (ë•…ì—ì„œ ì´ë™ ì¤‘ì¼ ë•Œë§Œ)
            if (moveDirection !== 0 && localPlayer.onGround) {
                sfxStep();
            }
            
            // ì¤‘ë ¥
            // ì í”„ ë†’ì´ë¥¼ 2/3ë¡œ ë‚®ì¶”ê¸° ìœ„í•´(ì²´ê° ë†’ì´ ê¸°ì¤€), ì¤‘ë ¥ë„ í•¨ê»˜ 2/3ë¡œ ì¡°ì •
            localPlayer.vy += 0.4;
            if (localPlayer.vy > 10) localPlayer.vy = 10;
            
            // ìœ„ì¹˜ ì—…ë°ì´íŠ¸
            localPlayer.x += localPlayer.vx;
            localPlayer.y += localPlayer.vy;
            
            // í”Œë«í¼ ì¶©ëŒ
            localPlayer.onGround = false;
            
            for (let platform of solidPlatforms()) {
                if (checkCollision(localPlayer, platform)) {
                    resolveCollision(localPlayer, platform);
                }
            }
            
            // ë‹«íŒ ë¬¸ê³¼ ì¶©ëŒ
            for (let door of gameObjects.doors) {
                if (!door.open && checkCollision(localPlayer, door)) {
                    resolveCollision(localPlayer, door);
                }
            }

            // í”Œë ˆì´ì–´-í”Œë ˆì´ì–´ ì¶©ëŒ (ìš”ì²­ì‚¬í•­: ì˜† ì¶©ëŒ + ìœ„ì— ì˜¬ë¼íƒ€ê¸° ê°€ëŠ¥)
            if (!isGuestMode) {
                try {
                    Object.entries(players).forEach(([sid, p]) => {
                        if (!p || p.isDead) return;
                        const rp = getInterpolatedRemote(sid, p || {});
                        const px = (typeof rp.x === 'number') ? rp.x : (p.x || 0);
                        const py = (typeof rp.y === 'number') ? rp.y : (p.y || 0);
                        const remoteRect = { x: px, y: py, width: 40, height: 40 };
                        if (checkCollision(localPlayer, remoteRect)) {
                            // Side collision should "push" the other player (requested).
                            resolvePlayerPlayerCollision(localPlayer, remoteRect, sid);
                        }
                    });
                } catch(_){ }
            }
            
            // ë°•ìŠ¤ ë¬¼ë¦¬
            for (let box of gameObjects.boxes) {
                // ë°•ìŠ¤ ì¤‘ë ¥
                box.vy += 0.4;
                if (box.vy > 10) box.vy = 10;
                
                // ë°•ìŠ¤ ìœ„ì¹˜ ì—…ë°ì´íŠ¸
                box.x += box.vx;
                box.y += box.vy;
                box.vx *= 0.8; // ë§ˆì°°
                
                // ë°•ìŠ¤-í”Œë«í¼ ì¶©ëŒ
                for (let platform of solidPlatforms()) {
                    if (checkBoxCollision(box, platform)) {
                        resolveBoxCollision(box, platform);
                    }
                }
                
                // ë°•ìŠ¤-ë¬¸ ì¶©ëŒ
                for (let door of gameObjects.doors) {
                    if (!door.open && checkBoxCollision(box, door)) {
                        resolveBoxCollision(box, door);
                    }
                }
            }
            
            // í”Œë ˆì´ì–´-ë°•ìŠ¤ ì¶©ëŒ (ë°€ê¸°)
            for (let box of gameObjects.boxes) {
                if (checkPlayerBoxCollision(localPlayer, box)) {
                    pushBox(localPlayer, box);
                }
            }
            
            // ë²„íŠ¼ ì²´í¬ (í”Œë ˆì´ì–´ ë˜ëŠ” ë°•ìŠ¤)
            gameObjects.buttons.forEach((button, idx) => {
                let somethingOnButton = false;
                
                // í”Œë ˆì´ì–´ê°€ ë²„íŠ¼ ìœ„ì— ìˆëŠ”ì§€
                const playerOnButton = localPlayer.x + 20 > button.x && 
                                localPlayer.x < button.x + button.width &&
                                localPlayer.y + 40 > button.y &&
                                localPlayer.y + 40 < button.y + button.height + 10;
                if (playerOnButton) somethingOnButton = true;
                
                // ë°•ìŠ¤ê°€ ë²„íŠ¼ ìœ„ì— ìˆëŠ”ì§€
                for (let box of gameObjects.boxes) {
                    const boxOnButton = box.x + box.width/2 > button.x && 
                                       box.x < button.x + button.width &&
                                       box.y + box.height > button.y &&
                                       box.y + box.height < button.y + button.height + 10;
                    if (boxOnButton) somethingOnButton = true;
                }
                
                // ë‹¤ë¥¸ í”Œë ˆì´ì–´ê°€ ë²„íŠ¼ ìœ„ì— ìˆëŠ”ì§€ (ë©€í‹°í”Œë ˆì´)
                if (!isGuestMode) {
                    Object.entries(players).forEach(([sid, p]) => {
                        const rp = getInterpolatedRemote(sid, p || {});
                        const px = (typeof rp.x === 'number') ? rp.x : (p.x || 0);
                        const py = (typeof rp.y === 'number') ? rp.y : (p.y || 0);
                        if (px + 20 > button.x && px < button.x + button.width &&
                            py + 40 > button.y && py + 40 < button.y + button.height + 10) {
                            somethingOnButton = true;
                        }
                    });
                }
                
                // ë²„íŠ¼ ìƒíƒœ ì—…ë°ì´íŠ¸
                if (somethingOnButton && !button.pressed) {
                    button.pressed = true;
                    sfxButton();
                    bridgeSend("tg_button", { idx, pressed: true });
                } else if (!somethingOnButton && button.pressed && !isGuestMode) {
                    // ë©€í‹° ëª¨ë“œì—ì„œë§Œ ë²„íŠ¼ í•´ì œ (ê²ŒìŠ¤íŠ¸ ëª¨ë“œëŠ” ë°•ìŠ¤ë¡œ ì˜êµ¬ ê³ ì •)
                    button.pressed = false;
                    bridgeSend("tg_button", { idx, pressed: false });
                }
            });
            
            localPlayer.onButton = gameObjects.buttons.some(btn => btn.pressed);
            
            updateDoors();
            updateBridges();
            updateLifts();
            
            // ì´ë¯¸ ì£½ì€ ìƒíƒœë©´ ì‚¬ë§ ì²˜ë¦¬ ìŠ¤í‚µ
            if (!localPlayer.isDead) {
                // ìŠ¤íŒŒì´í¬ ì¶©ëŒ (ì‚¬ë§)
                for (let spike of gameObjects.spikes) {
                    if (checkCollision(localPlayer, {...spike, height: 20})) {
                        onDeath();
                        return;
                    }
                }
                
                // ë‚™ì‚¬
                if (localPlayer.y > (stageBounds.maxY + 320)) {
                    onDeath();
                    return;
                }
            }
            
            // ê³¨ ì²´í¬
            const goal = gameObjects.goal;
            if (localPlayer.x + 20 > goal.x && localPlayer.x < goal.x + goal.width &&
                localPlayer.y + 40 > goal.y && localPlayer.y < goal.y + goal.height) {
                // 1ëª…ì´ë¼ë„ ë‹¿ìœ¼ë©´ ì „ì› ë‹¤ìŒ ë ˆë²¨ë¡œ (ì„œë²„ tg_level ë¸Œë¡œë“œìºìŠ¤íŠ¸)
                if (!levelClearLock) {
                    levelClearLock = true;
                    if (!document.getElementById('winScreen').classList.contains('show')) {
                        sfxLevelClear();
                        document.getElementById('winScreen').classList.add('show');
                    }

                    if (isGuestMode) {
                        setTimeout(() => { nextLevel(); }, 1500);
                    } else {
                        // ë©€í‹°: ëˆ„ê°€ ë„ì°©í•˜ë“  ì„œë²„ì— ë‹¤ìŒ ë ˆë²¨ ìš”ì²­
                        bridgeSend("tg_level", { level: currentLevel + 1 });
                        // í˜¹ì‹œ ë¸Œë¡œë“œìºìŠ¤íŠ¸ê°€ ëŠ¦ìœ¼ë©´ ì ê¸ˆ í•´ì œ(ì¬íŠ¸ë¦¬ê±° ê°€ëŠ¥)
                        setTimeout(() => { levelClearLock = false; }, 2000);
                    }
                }
            }

            // ë„¤íŠ¸ì›Œí¬(ë¸Œë¦¿ì§€)ë¡œ ìƒíƒœ ì „ì†¡
            bridgeSendState();
        }
        
        function updateDoors() {
            gameObjects.doors.forEach((door, idx) => {
                const button = gameObjects.buttons.find(b => b.doorId === idx);
                const wasOpen = door.open;
                door.open = button ? button.pressed : false;
                if (!wasOpen && door.open) {
                    sfxDoorOpen();
                }
            });
        }
        
        function onDeath() {
            localPlayer.isDead = true;
            deathCount++;
            updateDeathCountUI();
            sfxDeath();
            
            if (isGuestMode) {
                // ê²ŒìŠ¤íŠ¸ ëª¨ë“œ: ë°”ë¡œ ë§µ ì´ˆê¸°í™”
                showDeathEffect(() => {
                    resetMap();
                });
            } else {
                // ë©€í‹° í”Œë ˆì´: ë¸Œë¦¿ì§€ë¡œ ì‚¬ë§ ìƒíƒœ ì „ì†¡
                bridgeSendState(true);

                // ëª¨ë“  í”Œë ˆì´ì–´ ì‚¬ë§ ì²´í¬
                checkAllDead();
            }
        }
        
        function updateDeathCountUI() {
            document.getElementById('deathCount').textContent = 'ğŸ’€ ' + deathCount;
        }
        
        function showDeathEffect(callback) {
            // ê°„ë‹¨í•œ ì‚¬ë§ ì´í™íŠ¸ (í™”ë©´ ê¹œë¹¡ì„)
            const overlay = document.createElement('div');
            overlay.style.cssText = `
                position: fixed;
                top: 0;
                left: 0;
                width: 100%;
                height: 100%;
                background: rgba(255,0,0,0.3);
                z-index: 500;
                pointer-events: none;
            `;
            document.body.appendChild(overlay);
            
            setTimeout(() => {
                overlay.remove();
                if (callback) callback();
            }, 300);
        }
        
        function checkAllDead() {
            // ëª¨ë“  í”Œë ˆì´ì–´ê°€ ì‚¬ë§í–ˆëŠ”ì§€ í™•ì¸
            let allDead = localPlayer.isDead;
            
            Object.values(players).forEach(p => {
                if (!p.isDead) {
                    allDead = false;
                }
            });
            
            if (allDead && Object.keys(players).length > 0) {
                // ì„ë² ë“œ ë©€í‹°: ì „ì› ì‚¬ë§ = ì‹¤íŒ¨ -> ë¶€ëª¨/ì„œë²„ë¡œ ê²°ê³¼ ì „ì†¡
                if (EMBED && !isGuestMode) {
                    bridgeSendOver(false, "all_dead");
                    return;
                }
                // ê·¸ ì™¸(ë¡œì»¬/ê²ŒìŠ¤íŠ¸): í˜¸ìŠ¤íŠ¸ë§Œ ë§µ ë¦¬ì…‹ íŠ¸ë¦¬ê±°
                if (isHost) { bridgeSend("tg_reset", { t: Date.now() }); }
            } else if (allDead && Object.keys(players).length === 0) {
                // í˜¼ì í”Œë ˆì´ ì¤‘ì¸ ê²½ìš°(ì„ë² ë“œë©´ ì‹¤íŒ¨ë¡œ ì²˜ë¦¬)
                if (EMBED && !isGuestMode) {
                    bridgeSendOver(false, "all_dead");
                    return;
                }
                showDeathEffect(() => { resetMap(); });
            }
        }
        
        function resetMap() {
            // ë§µ ì´ˆê¸°í™” (ë²„íŠ¼, ë¬¸ ìƒíƒœ ë¦¬ì…‹)
            loadLevel(currentLevel);
            localPlayer.isDead = false;
            
            // ë¸Œë¦¿ì§€: ë¦¬ì…‹ ì „íŒŒ(í˜¸ìŠ¤íŠ¸ë§Œ)
            if (!isGuestMode && isHost) {
                bridgeSend("tg_reset", { t: Date.now() });
                gameObjects.buttons.forEach((btn, idx) => bridgeSend("tg_button", { idx, pressed: false }));
                bridgeSendState(true);
            }
        }
        
        function respawn() {
            // ê¸°ì¡´ respawnì€ ìœ„ì¹˜ë§Œ ë¦¬ì…‹ (ì‚¬ë§ ì—†ì´ ìœ„ì¹˜ ì¡°ì • í•„ìš”ì‹œ ì‚¬ìš©)
            const level = LEVELS[currentLevel - 1];
            const colorIndex = HAMSTER_COLORS.indexOf(localPlayer.color);
            localPlayer.x = level.spawn.x + (colorIndex * 50);
            localPlayer.y = level.spawn.y;
            localPlayer.vx = 0;
            localPlayer.vy = 0;
        }
        
        function checkCollision(player, rect) {
            return player.x + 40 > rect.x &&
                   player.x < rect.x + rect.width &&
                   player.y + 40 > rect.y &&
                   player.y < rect.y + rect.height;
        }
        
        function resolveCollision(player, rect) {
            const overlapX = Math.min(player.x + 40 - rect.x, rect.x + rect.width - player.x);
            const overlapY = Math.min(player.y + 40 - rect.y, rect.y + rect.height - player.y);
            
            if (overlapX < overlapY) {
                if (player.x < rect.x) {
                    player.x = rect.x - 40;
                } else {
                    player.x = rect.x + rect.width;
                }
                player.vx = 0;
            } else {
                if (player.y < rect.y) {
                    player.y = rect.y - 40;
                    player.onGround = true;
                    player.vy = 0;
                } else {
                    player.y = rect.y + rect.height;
                    player.vy = 0;
                }
            }
        }

        // í”Œë ˆì´ì–´-í”Œë ˆì´ì–´ ì¶©ëŒ í•´ê²° (ì˜† ì¶©ëŒ ì‹œ ìƒëŒ€ë¥¼ 'ë°€ê¸°')
        // NOTE: ê° í”Œë ˆì´ì–´ëŠ” ìì‹ ì˜ ìƒíƒœë§Œ ì„œë²„ë¡œ ì „ì†¡í•˜ë¯€ë¡œ,
        //       ë°€ë¦¼ì€ 'push impulse' ì´ë²¤íŠ¸ë¥¼ ìƒëŒ€ì—ê²Œ ì „ë‹¬í•´ ì ìš©í•©ë‹ˆë‹¤.
        function bridgeSendPush(toSid, dx){
            if (!EMBED || isGuestMode) return;
            const sid = String(toSid || "");
            if (!sid || sid === mySessionId) return;
            const now = performance.now();
            if (!bridgeSendPush._last) bridgeSendPush._last = {};
            const last = bridgeSendPush._last[sid] || 0;
            if (now - last < 120) return; // throttle
            bridgeSendPush._last[sid] = now;

            const v = clamp(Number(dx) || 0, -10, 10);
            if (!v) return;
            bridgeSend("tg_push", { to: sid, dx: v });
        }

        function resolvePlayerPlayerCollision(player, rect, remoteSid){
            const overlapX = Math.min(player.x + 40 - rect.x, rect.x + rect.width - player.x);
            const overlapY = Math.min(player.y + 40 - rect.y, rect.y + rect.height - player.y);

            if (overlapX < overlapY) {
                // Side collision: separate X but keep some velocity, and push the other player
                if (player.x < rect.x) {
                    player.x = rect.x - 40;
                    if (player.vx > 0.2) bridgeSendPush(remoteSid, player.vx * 0.95);
                } else {
                    player.x = rect.x + rect.width;
                    if (player.vx < -0.2) bridgeSendPush(remoteSid, player.vx * 0.95);
                }
                // friction so it doesn't jitter-stick
                player.vx *= 0.35;
            } else {
                // Vertical collision: allow standing on top of others
                if (player.y < rect.y) {
                    player.y = rect.y - 40;
                    player.onGround = true;
                    player.vy = 0;
                } else {
                    player.y = rect.y + rect.height;
                    player.vy = 0;
                }
            }
        }
        
        // ë°•ìŠ¤ ì¶©ëŒ ì²´í¬
        function checkBoxCollision(box, rect) {
            return box.x + box.width > rect.x &&
                   box.x < rect.x + rect.width &&
                   box.y + box.height > rect.y &&
                   box.y < rect.y + rect.height;
        }
        
        // ë°•ìŠ¤ ì¶©ëŒ í•´ê²°
        function resolveBoxCollision(box, rect) {
            const overlapX = Math.min(box.x + box.width - rect.x, rect.x + rect.width - box.x);
            const overlapY = Math.min(box.y + box.height - rect.y, rect.y + rect.height - box.y);
            
            if (overlapX < overlapY) {
                if (box.x < rect.x) {
                    box.x = rect.x - box.width;
                } else {
                    box.x = rect.x + rect.width;
                }
                box.vx = 0;
            } else {
                if (box.y < rect.y) {
                    box.y = rect.y - box.height;
                    box.vy = 0;
                } else {
                    box.y = rect.y + rect.height;
                    box.vy = 0;
                }
            }
        }
        
        // í”Œë ˆì´ì–´-ë°•ìŠ¤ ì¶©ëŒ ì²´í¬
        function checkPlayerBoxCollision(player, box) {
            return player.x + 40 > box.x &&
                   player.x < box.x + box.width &&
                   player.y + 40 > box.y &&
                   player.y < box.y + box.height;
        }
        
        // ë°•ìŠ¤ ë°€ê¸°
        function pushBox(player, box) {
            const overlapX = Math.min(player.x + 40 - box.x, box.x + box.width - player.x);
            const overlapY = Math.min(player.y + 40 - box.y, box.y + box.height - player.y);
            
            if (overlapX < overlapY) {
                // ì˜†ì—ì„œ ì¶©ëŒ - ë°•ìŠ¤ ë°€ê¸°
                sfxPush();
                if (player.x < box.x) {
                    box.vx = 3;
                    player.x = box.x - 40;
                } else {
                    box.vx = -3;
                    player.x = box.x + box.width;
                }
            } else {
                // ìœ„ì•„ë˜ ì¶©ëŒ
                if (player.y < box.y) {
                    // í”Œë ˆì´ì–´ê°€ ë°•ìŠ¤ ìœ„ì— ì°©ì§€
                    player.y = box.y - 40;
                    player.onGround = true;
                    player.vy = 0;
                } else {
                    // í”Œë ˆì´ì–´ê°€ ë°•ìŠ¤ ì•„ë˜ì—ì„œ ë¶€ë”ªí˜
                    player.y = box.y + box.height;
                    player.vy = 0;
                }
            }
        }
        
        

        // ===== ê¸°ë¯¹: ë¦¬í”„íŠ¸/ìƒì„±í˜• ë‹¤ë¦¬ =====
        function solidPlatforms() {
            const base = (gameObjects && gameObjects.platforms) ? gameObjects.platforms : [];
            const lifts = (gameObjects && gameObjects.lifts) ? gameObjects.lifts : [];
            const bridges = (gameObjects && gameObjects.bridges) ? gameObjects.bridges.filter(b => b.active) : [];
            return base.concat(lifts, bridges);
        }

        function updateLifts() {
            if (!gameObjects || !gameObjects.lifts) return;
            gameObjects.lifts.forEach((lift, idx) => {
                const btn = (gameObjects.buttons || []).find(b => b.liftId === idx);
                const active = btn ? !!btn.pressed : false;
                const minY = (typeof lift.minY === 'number') ? lift.minY : lift.y;
                const maxY = (typeof lift.maxY === 'number') ? lift.maxY : lift.y;
                const targetY = active ? minY : maxY;
                const speed = (typeof lift.speed === 'number') ? lift.speed : 2;
                const dy = targetY - lift.y;
                if (Math.abs(dy) <= speed) {
                    lift.y = targetY;
                } else {
                    lift.y += Math.sign(dy) * speed;
                }
            });
        }

        function updateBridges() {
            if (!gameObjects || !gameObjects.bridges) return;
            gameObjects.bridges.forEach((br, idx) => {
                const btn = (gameObjects.buttons || []).find(b => b.bridgeId === idx);
                br.active = btn ? !!btn.pressed : false;
            });
        }

// ==================== ë Œë”ë§ ====================
        function render() {
            // ë°°ê²½
            const gradient = ctx.createLinearGradient(0, 0, 0, canvas.height);
            gradient.addColorStop(0, '#1a1a2e');
            gradient.addColorStop(0.5, '#16213e');
            gradient.addColorStop(1, '#0f3460');
            ctx.fillStyle = gradient;
            ctx.fillRect(0, 0, canvas.width, canvas.height);
            
            // ì¹´ë©”ë¼ ë”°ë¼ê°€ê¸° (ëª¨ë°”ì¼ ì„¸ë¡œ ì§„í–‰: X/Y ëª¨ë‘ ì¶”ì )
            const targetCameraX = localPlayer.x - canvas.width / 2;
            const targetCameraY = localPlayer.y - canvas.height / 2;
            cameraX += (targetCameraX - cameraX) * 0.12;
            cameraY += (targetCameraY - cameraY) * 0.12;

            cameraX = clamp(cameraX, stageBounds.minX, stageBounds.maxX - canvas.width);
            cameraY = clamp(cameraY, stageBounds.minY, stageBounds.maxY - canvas.height);

            ctx.save();
            ctx.translate(-cameraX, -cameraY);
// ë°°ê²½ ë³„
            for (let i = 0; i < 50; i++) {
                const x = (i * 73 + cameraX * 0.1) % 2500 + cameraX;
                const y = (i * 47 + cameraY * 0.1) % 2500 + cameraY;
                ctx.fillStyle = `rgba(255,255,255,${0.3 + Math.sin(Date.now() / 1000 + i) * 0.2})`;
                ctx.beginPath();
                ctx.arc(x, y, 1 + Math.random(), 0, Math.PI * 2);
                ctx.fill();
            }
            
            // í”Œë«í¼
            gameObjects.platforms.forEach(p => {
                ctx.fillStyle = p.color;
                ctx.fillRect(p.x, p.y, p.width, p.height);
                
                // í•˜ì´ë¼ì´íŠ¸
                ctx.fillStyle = 'rgba(255,255,255,0.1)';
                ctx.fillRect(p.x, p.y, p.width, 3);
            });
            

            
            // ìƒì„±í˜• ë‹¤ë¦¬ (ë²„íŠ¼ ì—°ë™)
            (gameObjects.bridges || []).forEach((br) => {
                if (br.active) {
                    ctx.fillStyle = br.color || '#74b9ff';
                    ctx.fillRect(br.x, br.y, br.width, br.height);
                    // í•˜ì´ë¼ì´íŠ¸
                    ctx.fillStyle = 'rgba(255,255,255,0.12)';
                    ctx.fillRect(br.x, br.y, br.width, 3);
                } else {
                    // ë¹„í™œì„±: ìœ„ì¹˜ íŒíŠ¸(ì ì„ )
                    ctx.strokeStyle = 'rgba(116,185,255,0.25)';
                    ctx.lineWidth = 2;
                    ctx.setLineDash([8, 6]);
                    ctx.strokeRect(br.x, br.y, br.width, br.height);
                    ctx.setLineDash([]);
                }
            });
            
            // ë¦¬í”„íŠ¸ (ë²„íŠ¼ ì—°ë™)
            (gameObjects.lifts || []).forEach((l) => {
                ctx.fillStyle = l.color || '#b2bec3';
                ctx.fillRect(l.x, l.y, l.width, l.height);
                // ìŠ¤íŠ¸ë¼ì´í”„
                ctx.fillStyle = 'rgba(0,0,0,0.2)';
                const stripes = Math.max(1, Math.floor(l.width / 24));
                for (let i = 0; i < stripes; i++) {
                    ctx.fillRect(l.x + 6 + i * 24, l.y + 3, 10, Math.max(1, l.height - 6));
                }
                // í•˜ì´ë¼ì´íŠ¸
                ctx.fillStyle = 'rgba(255,255,255,0.12)';
                ctx.fillRect(l.x, l.y, l.width, 2);
            });
            // ë²„íŠ¼
            gameObjects.buttons.forEach(b => {
                ctx.fillStyle = b.pressed ? '#2d3436' : b.color;
                ctx.fillRect(b.x, b.y + (b.pressed ? 10 : 0), b.width, b.height - (b.pressed ? 5 : 0));
                
                if (!b.pressed) {
                    ctx.fillStyle = 'rgba(255,255,255,0.3)';
                    ctx.fillRect(b.x, b.y, b.width, 3);
                }
            });
            
            // ë¬¸
            gameObjects.doors.forEach(d => {
                if (!d.open) {
                    ctx.fillStyle = d.color;
                    ctx.fillRect(d.x, d.y, d.width, d.height);
                    
                    // íŒ¨í„´
                    ctx.fillStyle = 'rgba(0,0,0,0.3)';
                    for (let i = 0; i < 3; i++) {
                        ctx.fillRect(d.x + 5, d.y + 10 + i * 30, d.width - 10, 20);
                    }
                } else {
                    // ì—´ë¦° ë¬¸
                    ctx.fillStyle = 'rgba(255,255,255,0.2)';
                    ctx.fillRect(d.x, d.y, d.width, d.height);
                }
            });
            
            // ìŠ¤íŒŒì´í¬
            gameObjects.spikes.forEach(s => {
                ctx.fillStyle = '#e74c3c';
                const spikeCount = Math.floor(s.width / 15);
                for (let i = 0; i < spikeCount; i++) {
                    ctx.beginPath();
                    ctx.moveTo(s.x + i * 15, s.y + s.height);
                    ctx.lineTo(s.x + i * 15 + 7.5, s.y);
                    ctx.lineTo(s.x + i * 15 + 15, s.y + s.height);
                    ctx.fill();
                }
            });
            
            // ë°•ìŠ¤
            gameObjects.boxes.forEach(box => {
                // ê·¸ë¦¼ì
                ctx.fillStyle = 'rgba(0,0,0,0.3)';
                ctx.fillRect(box.x + 4, box.y + 4, box.width, box.height);
                
                // ë°•ìŠ¤ ë³¸ì²´
                ctx.fillStyle = '#8b4513';
                ctx.fillRect(box.x, box.y, box.width, box.height);
                
                // ë‚˜ë¬´ ë¬´ëŠ¬
                ctx.fillStyle = '#a0522d';
                ctx.fillRect(box.x + 3, box.y + 3, box.width - 6, 8);
                ctx.fillRect(box.x + 3, box.y + box.height - 11, box.width - 6, 8);
                
                // í•˜ì´ë¼ì´íŠ¸
                ctx.fillStyle = 'rgba(255,255,255,0.2)';
                ctx.fillRect(box.x, box.y, box.width, 3);
                ctx.fillRect(box.x, box.y, 3, box.height);
                
                // í…Œë‘ë¦¬
                ctx.strokeStyle = '#5c3317';
                ctx.lineWidth = 2;
                ctx.strokeRect(box.x, box.y, box.width, box.height);
            });
            
            // ê³¨ - ê¹ƒë°œë§Œ í‘œì‹œ
            const goal = gameObjects.goal;
            const flagX = goal.x + goal.width / 2;
            const flagY = goal.y - 30; // ë” ë†’ê²Œ
            const flagHeight = goal.height + 30;
            
            // ê¹ƒë°œ ê¸°ë‘¥
            ctx.fillStyle = '#ffd700';
            ctx.fillRect(flagX - 3, flagY, 6, flagHeight);
            
            // ê¹ƒë°œ ì²œ
            ctx.beginPath();
            ctx.moveTo(flagX + 3, flagY);
            ctx.lineTo(flagX + 45, flagY + 22);
            ctx.lineTo(flagX + 3, flagY + 44);
            ctx.closePath();
            ctx.fillStyle = '#ff6b6b';
            ctx.fill();
            
            // ë°˜ì§ì´ íŒŒí‹°í´ 2~3ê°œ (ìì—°ìŠ¤ëŸ½ê²Œ ë– ë‹¤ë‹ˆëŠ” ëŠë‚Œ)
            const time = Date.now() / 1000;
            for (let i = 0; i < 3; i++) {
                const px = flagX + 20 + Math.sin(time * 0.8 + i * 2.5) * 25;
                const py = flagY + 20 + Math.cos(time * 0.6 + i * 2) * 20 + i * 10;
                const alpha = 0.6 + Math.sin(time * 2 + i) * 0.4;
                ctx.fillStyle = `rgba(255, 255, 150, ${alpha})`;
                ctx.beginPath();
                ctx.arc(px, py, 3, 0, Math.PI * 2);
                ctx.fill();
            }
            
            // ë‹¤ë¥¸ í”Œë ˆì´ì–´ë“¤ (íˆìŠ¤í† ë¦¬ ê¸°ë°˜ ë³´ê°„/ì˜ˆì¸¡ + ìŠ¤ë¬´ë”©)
            Object.entries(players).forEach(([sid, p]) => {
                const tp = getInterpolatedRemote(sid, p || {});
                const initX = (typeof tp.x === 'number') ? tp.x : 0;
                const initY = (typeof tp.y === 'number') ? tp.y : 0;
                const sp = smoothedPlayers[sid] || (smoothedPlayers[sid] = { x: initX, y: initY });

                const tx = (typeof tp.x === 'number') ? tp.x : 0;
                const ty = (typeof tp.y === 'number') ? tp.y : 0;
                const dx = tx - sp.x;
                const dy = ty - sp.y;
                const dist = Math.hypot(dx, dy);

                // ìˆœê°„ì´ë™ê¸‰ ì°¨ì´ëŠ” ë°”ë¡œ ìŠ¤ëƒ… (ì‹¬í•œ ëŠê¹€/íŠ€ëŠ” ëŠë‚Œ ë°©ì§€)
                if (dist > 220) {
                    sp.x = tx;
                    sp.y = ty;
                } else {
                    const k = 0.35;
                    sp.x += dx * k;
                    sp.y += dy * k;
                }

                sp.color = tp.color || p.color;
                sp.name = tp.name || p.name;
                sp.isDead = !!tp.isDead;
                sp.vx = (typeof tp.vx === 'number') ? tp.vx : (p.vx || 0);
                sp.vy = (typeof tp.vy === 'number') ? tp.vy : (p.vy || 0);
                sp.onGround = (typeof tp.onGround === 'boolean') ? tp.onGround : !!p.onGround;
                if (!sp.facing) sp.facing = 1;
                if (Math.abs(sp.vx) > 0.3) sp.facing = sp.vx < 0 ? -1 : 1;

                drawHamster(sp.x, sp.y, sp.color, sp.name, false, sp.isDead, { vx: sp.vx, vy: sp.vy, onGround: sp.onGround, facing: sp.facing });
            });
// ë¡œì»¬ í”Œë ˆì´ì–´
            drawHamster(localPlayer.x, localPlayer.y, localPlayer.color, localPlayer.name, true, localPlayer.isDead, localPlayer);
            
            ctx.restore();
        }
        
                // ==================== ìºë¦­í„° ë Œë”ë§ (í”½ì…€ / 2ë“±ì‹  + ê·€/ê¼¬ë¦¬ + ê°„ë‹¨ ì• ë‹ˆë©”ì´ì…˜) ====================
        function _hexToRgb(hex){
            const h = (hex || '#000000').replace('#','').trim();
            const v = h.length === 3 ? h.split('').map(c=>c+c).join('') : h.padEnd(6,'0').slice(0,6);
            const n = parseInt(v,16);
            return { r:(n>>16)&255, g:(n>>8)&255, b:n&255 };
        }
        function _rgbToHex(r,g,b){
            const to = (x)=>('0'+Math.max(0,Math.min(255,Math.round(x))).toString(16)).slice(-2);
            return '#'+to(r)+to(g)+to(b);
        }
        function _shade(hex, amt){
            const {r,g,b} = _hexToRgb(hex);
            // amt: -100..100
            const f = (x)=> x + (amt/100) * (amt>0 ? (255-x) : x);
            return _rgbToHex(f(r), f(g), f(b));
        }

        function drawHamster(x, y, color, name, isLocal = false, isDead = false, state = null) {
            const s = state || {};
            const vx = (typeof s.vx === 'number') ? s.vx : 0;
            const vy = (typeof s.vy === 'number') ? s.vy : 0;
            const onGround = (typeof s.onGround === 'boolean') ? s.onGround : false;
            const facing = (typeof s.facing === 'number') ? s.facing : (vx < -0.2 ? -1 : 1);
            const variant = (typeof s.variant === 'number') ? s.variant : 0;

            // ì‚¬ë§ ì‹œ ë°˜íˆ¬ëª… ì²˜ë¦¬
            if (isDead) ctx.globalAlpha = 0.4;

            // ê·¸ë¦¼ì (ê¸°ì¡´ ìœ ì§€)
            ctx.fillStyle = 'rgba(0,0,0,0.2)';
            ctx.beginPath();
            ctx.ellipse(x + 20, y + 38, 14, 4, 0, 0, Math.PI * 2);
            ctx.fill();

            // í”½ì…€ ìŠ¤ì¼€ì¼/í¬ê¸°
            const PX = 2;         // 1px = 2 screen px
            const W = 16, H = 18; // sprite pixels (2ë“±ì‹  ëŠë‚Œ)
            const drawW = W * PX, drawH = H * PX;

            // íˆíŠ¸ë°•ìŠ¤(40x40) ë°”ë‹¥ì— ìŠ¤í”„ë¼ì´íŠ¸ë¥¼ ì •ë ¬
            const baseX = Math.round(x + 20 - drawW / 2);
            const baseY = Math.round(y + 40 - drawH);

            // ì• ë‹ˆë©”ì´ì…˜ íŒŒë¼ë¯¸í„°
            const t = performance.now() / 1000;
            const moving = onGround && Math.abs(vx) > 0.6;
            const jumping = !onGround && vy < -0.6;

            const walkPhase = moving ? (Math.floor(t * 10) % 2) : 0;
            const bob = moving ? Math.sin(t * 12) * 0.8 : Math.sin(t * 2.2) * 0.4;
            const bobPx = Math.round(bob); // pixel ë‹¨ìœ„

            // íŒ”/ë‹¤ë¦¬ í¬ì¦ˆ
            const armUp = jumping;
            const legsTuck = !onGround;

            // ê¼¬ë¦¬ í”ë“¤ë¦¼
            const tailWag = moving ? (walkPhase ? 1 : -1) : (Math.sin(t * 3) > 0 ? 1 : -1);

            // ì»¬ëŸ¬ íŒ”ë ˆíŠ¸ (í”Œë ˆì´ì–´ ìƒ‰ ê¸°ë°˜)
            const OUT = _shade(color, -45);
            const BASE = color;
            const HI = _shade(color, 25);
            // ìš”ì²­: ì–¼êµ´(ì–¼êµ´/ë°° ì˜ì—­)ì€ ì‚´ìƒ‰ìœ¼ë¡œ ê³ ì •
            const FACE = '#f2c8a0';
            const HAIR = _shade(color, -65);
            const INNER = '#ffb8d0';
            const EYE = '#1f1f1f';
            const BLUSH = 'rgba(255,184,208,0.8)';

            // í”½ì…€ ê·¸ë¦¬ê¸° í—¬í¼
            const p = (px, py, w, h, c) => {
                if (w === undefined) w = 1;
                if (h === undefined) h = 1;
                ctx.fillStyle = c;
                ctx.fillRect(baseX + px * PX, baseY + (py + bobPx) * PX, w * PX, h * PX);
            };

            // ì¢Œìš° ë°˜ì „(ë°©í–¥)
            ctx.save();
            ctx.imageSmoothingEnabled = false;
            const cx = baseX + drawW / 2;
            const cy = baseY + drawH / 2;
            ctx.translate(cx, cy);
            ctx.scale(facing, 1);
            ctx.translate(-cx, -cy);

            // ===== ê¼¬ë¦¬ (ë¨¼ì €) =====
            const tw = tailWag;
            p(1 + (tw > 0 ? 0 : 1), 11, 2, 1, OUT);
            p(1 + (tw > 0 ? 0 : 1), 12, 3, 2, OUT);
            p(2 + (tw > 0 ? 0 : 1), 12, 2, 2, BASE);
            p(3 + (tw > 0 ? 0 : 1), 13, 1, 1, HI);

            // ===== ëª¸í†µ =====
            p(4, 9, 8, 7, OUT);
            p(5, 10, 6, 5, BASE);
            p(6, 11, 4, 3, FACE);
            // ê°œì„± í¬ì¸íŠ¸(ë°”ë”” ë¬´ëŠ¬)
            if (variant === 1) { p(6, 12, 4, 1, HI); }
            if (variant === 2) { p(7, 12, 2, 1, INNER); }
            if (variant === 3) { p(8, 11, 1, 2, HI); }


            // ===== ë¨¸ë¦¬ =====
            p(3, 2, 10, 8, OUT);
            p(4, 3, 8, 6, BASE);
            p(5, 4, 6, 4, FACE);

            // 4ëª… ê°ê° ì‘ì€ í¬ì¸íŠ¸(ìƒ‰/ì¥ì‹ë§Œ ë‹¤ë¥´ê²Œ)(ìƒ‰/ì¥ì‹ë§Œ ë‹¤ë¥´ê²Œ)
            if (variant === 0){
                // ë¦¬ë³¸
                p(3, 4, 1, 1, '#ffd1dc');
                p(4, 4, 1, 1, '#ffd1dc');
            } else if (variant === 1){
                // ë³„ ë¨¸ë¦¬í•€
                p(11, 3, 1, 1, '#ffe66d');
                p(12, 3, 1, 1, '#ffe66d');
            } else if (variant === 2){
                // í—¤ì–´ë°´ë“œ
                p(4, 3, 8, 1, 'rgba(255,255,255,0.9)');
            } else if (variant === 3){
                // ì‘ì€ ê½ƒ
                p(4, 5, 1, 1, '#ffb8d0');
                p(4, 6, 1, 1, '#ff6b6b');
            }

// ===== ê·€ =====
            p(4, 0, 3, 3, OUT);
            p(9, 0, 3, 3, OUT);
            p(5, 1, 2, 2, BASE);
            p(10, 1, 2, 2, BASE);
            p(6, 2, 1, 1, INNER);
            p(11, 2, 1, 1, INNER);

            // ===== íŒ” =====
            if (armUp) {
                p(2, 8, 2, 2, OUT);
                p(12, 8, 2, 2, OUT);
                p(3, 9, 1, 1, BASE);
                p(12, 9, 1, 1, BASE);
            } else {
                p(3, 11, 2, 3, OUT);
                p(11, 11, 2, 3, OUT);
                p(4, 12, 1, 2, BASE);
                p(11, 12, 1, 2, BASE);
            }

            // ===== ë‹¤ë¦¬ =====
            if (legsTuck) {
                p(6, 15, 2, 2, OUT);
                p(8, 15, 2, 2, OUT);
                p(7, 16, 1, 1, BASE);
                p(9, 16, 1, 1, BASE);
            } else {
                const a = walkPhase ? 1 : 0;
                p(6, 15, 2, 2, OUT);
                p(9, 15, 2, 2, OUT);
                p(7, 16 - a, 1, 1, BASE);
                p(10, 16 - (1 - a), 1, 1, BASE);
            }

            // ===== ì–¼êµ´ =====
            // ===== ëˆˆ (ì„¸ë¡œ 2px) =====
            p(6, 6, 1, 2, EYE);
            p(10, 6, 1, 2, EYE);
            // í•˜ì´ë¼ì´íŠ¸(ìœ„ìª½ 1px)
            p(6, 5, 1, 1, 'rgba(255,255,255,0.9)');
            p(10, 5, 1, 1, 'rgba(255,255,255,0.9)');
            // ì½”/ì…
            p(8, 7, 1, 1, INNER);
            p(8, 8, 2, 1, OUT);

            // ë³¼í„°ì¹˜
            ctx.fillStyle = BLUSH;
            ctx.fillRect(baseX + 5 * PX, baseY + (8 + bobPx) * PX, 2 * PX, 1 * PX);
            ctx.fillRect(baseX + 9 * PX, baseY + (8 + bobPx) * PX, 2 * PX, 1 * PX);

            // ë¡œì»¬ í‘œì‹œ(í”½ì…€ í™”ì‚´í‘œ)
            if (isLocal && !isDead) {
                p(7, -2, 2, 1, '#ffd700');
                p(8, -3, 1, 1, '#ffd700');
            }

            // ì‚¬ë§ í‘œì‹œ (í”½ì…€ X)
            if (isDead) {
                ctx.globalAlpha = 1;
                ctx.fillStyle = '#ff3b3b';
                for (let i = 0; i < 6; i++) {
                    ctx.fillRect(baseX + (5 + i) * PX, baseY + (4 + i + bobPx) * PX, PX, PX);
                    ctx.fillRect(baseX + (10 - i) * PX, baseY + (4 + i + bobPx) * PX, PX, PX);
                }
            }

            ctx.restore();

            // ì´ë¦„í‘œ (ì´ë¦„ì´ ìˆì„ ë•Œë§Œ)
            if (name) {
                ctx.fillStyle = 'rgba(0,0,0,0.6)';
                ctx.beginPath();
                ctx.roundRect(x - 5, y - 15, 50, 14, 7);
                ctx.fill();

                ctx.fillStyle = '#fff';
                ctx.font = '9px Jua';
                ctx.textAlign = 'center';
                ctx.fillText(name, x + 20, y - 4);
            }

            // globalAlpha ë³µì›
            ctx.globalAlpha = 1;
        }

        // ==================== ê²Œì„ ë£¨í”„ ====================
        function gameLoop() {
            if (!gameRunning) return;
            updatePhysics();
            render();
            rafId = requestAnimationFrame(gameLoop);
        }
        
        
        // ==================== Colyseus ë¸Œë¦¿ì§€ (Firebase ì œê±°) ====================
        let mySessionId = null;
        let mySeat = 0;
        let tgEnded = false; // embed ë©€í‹°ì—ì„œ ê²°ê³¼ ì „ì†¡ ì¤‘ë³µ ë°©ì§€

        function bridgeSendOver(success, reason){
            if (!EMBED || isGuestMode) return;
            if (tgEnded) return;
            tgEnded = true;
            bridgeSend("tg_over", { success: !!success, reason: reason || (success ? "clear" : "fail") });
        }

        // ==================== ì›ê²© í”Œë ˆì´ì–´ ë³´ê°„/ì˜ˆì¸¡ ====================
        function recordRemoteSnapshot(sid, p){
            const now = performance.now();
            const arr = remoteHistory[sid] || (remoteHistory[sid] = []);
            arr.push({
                t: now,
                x: (p && typeof p.x === 'number') ? p.x : (p?.x || 0),
                y: (p && typeof p.y === 'number') ? p.y : (p?.y || 0),
                vx: (p && typeof p.vx === 'number') ? p.vx : (p?.vx || 0),
                vy: (p && typeof p.vy === 'number') ? p.vy : (p?.vy || 0),
                onGround: !!p?.onGround,
                isDead: !!p?.isDead,
                color: p?.color,
                name: p?.name,
                variant: (typeof p?.variant === 'number') ? p.variant : 0
            });

            // íˆìŠ¤í† ë¦¬ ì •ë¦¬
            const cutoff = now - NET_MAX_HISTORY_MS;
            while (arr.length > 2 && arr[1].t < cutoff) arr.shift();
            if (arr.length > 80) arr.splice(0, arr.length - 80);
        }

        function getInterpolatedRemote(sid, fallback){
            const hist = remoteHistory[sid];
            const now = performance.now();
            const renderT = now - NET_INTERP_DELAY_MS;
            if (!hist || hist.length === 0) return fallback || { x: 0, y: 0 };

            // ë„ˆë¬´ ì˜¤ë˜ëœ íˆìŠ¤í† ë¦¬ ì •ë¦¬
            const cutoff = now - NET_MAX_HISTORY_MS;
            while (hist.length > 2 && hist[1].t < cutoff) hist.shift();

            // renderT ì´ì „ì˜ ë§ˆì§€ë§‰ ìŠ¤ëƒ…ìƒ· ì°¾ê¸°
            let i = 0;
            while (i < hist.length - 1 && hist[i + 1].t <= renderT) i++;

            const a = hist[i];
            const b = hist[i + 1];

            // êµ¬ê°„ ë³´ê°„
            if (b && a.t <= renderT && renderT <= b.t) {
                const span = (b.t - a.t) || 1;
                const alpha = (renderT - a.t) / span;
                return {
                    x: a.x + (b.x - a.x) * alpha,
                    y: a.y + (b.y - a.y) * alpha,
                    vx: b.vx,
                    vy: b.vy,
                    onGround: !!b.onGround,
                    isDead: !!b.isDead,
                    color: b.color,
                    name: b.name,
                    variant: (typeof b.variant === 'number') ? b.variant : 0
                };
            }

            // ìµœì‹  ìŠ¤ëƒ…ìƒ· ì´í›„ë©´ ì§§ê²Œ ì˜ˆì¸¡ (ëŠê¹€ ì™„í™”)
            const last = hist[hist.length - 1];
            const dtMs = Math.max(0, Math.min(200, renderT - last.t));
            const frames = dtMs / 16.6667;
            const g = 0.4;
            return {
                x: last.x + (last.vx || 0) * frames,
                y: last.y + (last.vy || 0) * frames + 0.5 * g * frames * frames,
                vx: last.vx,
                vy: last.vy,
                onGround: !!last.onGround,
                isDead: !!last.isDead,
                color: last.color,
                name: last.name,
                variant: (typeof last.variant === 'number') ? last.variant : 0
            };
        }

        function applyRemotePlayers(map){
            const next = {};
            if (!map) map = {};
            for (const [sid, p] of Object.entries(map)){
                if (sid === mySessionId) continue;
                next[sid] = p;
                // ìŠ¤ëƒ…ìƒ· ê¸°ë¡ (ë³´ê°„/ì˜ˆì¸¡)
                recordRemoteSnapshot(sid, p);
                // init smoothing slot
                if (!smoothedPlayers[sid]){
                    smoothedPlayers[sid] = { x: p.x||0, y: p.y||0, vx: p.vx||0, vy: p.vy||0, onGround: !!p.onGround, isDead: !!p.isDead };
                }
                // keep name/color immediately (no alpha)
                smoothedPlayers[sid].name = p.name;
                smoothedPlayers[sid].color = p.color;
                smoothedPlayers[sid].variant = (typeof p.variant === 'number') ? p.variant : 0;
            }
            players = next;
            // prune removed
            for (const sid of Object.keys(smoothedPlayers)){
                if (!players[sid]) delete smoothedPlayers[sid];
            }
            for (const sid of Object.keys(remoteHistory)){
                if (!players[sid]) delete remoteHistory[sid];
            }
            updatePlayerList();
        }

        function applyButtons(btnMap){
            if (!btnMap || !gameObjects?.buttons) return;
            for (const [idxStr, pressed] of Object.entries(btnMap)){
                const idx = parseInt(idxStr, 10);
                if (gameObjects.buttons[idx]) gameObjects.buttons[idx].pressed = !!pressed;
            }
            updateDoors();
            updateBridges();
            updateLifts();
        }

        function bridgeSendState(force=false){
            if (!EMBED || isGuestMode) return;
            const now = performance.now();
            if (!force && bridgeSendState._t && (now - bridgeSendState._t) < 33) return; // ~20Hz
            bridgeSendState._t = now;
            bridgeSend("tg_state", {
                state: {
                    x: localPlayer.x, y: localPlayer.y,
                    vx: localPlayer.vx, vy: localPlayer.vy,
                    onGround: !!localPlayer.onGround,
                    onButton: !!localPlayer.onButton,
                    isDead: !!localPlayer.isDead,
                    color: localPlayer.color,
                    name: localPlayer.name,
                    level: currentLevel,
                    deathCount,
                    variant: localPlayer.variant
                }
            });
        }

        // Embed ëª¨ë“œ ì§„ì…: ë‚´ë¶€ ë¡œë¹„/ì„¤ì • UI ì œê±°, ë¶€ëª¨ì—ê²Œ ì¤€ë¹„ ì‹ í˜¸
        if (EMBED){
            try{
                const lobby = document.getElementById('lobby');
                if (lobby){
                    // ë¡œë¹„ UIëŠ” ë¶€ëª¨ ë¡œë¹„ë¥¼ ì‚¬ìš©í•˜ë¯€ë¡œ ìµœì†Œí™”
                    const hide = lobby.querySelectorAll('button, details, .input-group');
                    hide.forEach(el => el.style.display = 'none');
                    const subtitle = lobby.querySelector('.lobby-subtitle');
                    if (subtitle) subtitle.textContent = 'ì—°ê²° ì¤‘...';
                }
                bridgeSend("bridge_ready", {});
            }catch(e){}
        }

        window.addEventListener("message", (e)=>{
            const d = e.data || {};
            if (!d || typeof d !== "object") return;

            if (d.type === "bridge_init"){
                mySessionId = String(d.sessionId || "");
                mySeat = typeof d.seat === "number" ? d.seat : 0;
                startEmbedded({
                    nick: d.nick || "í–„ì°Œ",
                    seat: mySeat,
                    isHost: !!d.isHost,
                    sessionId: mySessionId,
                    roomCode: d.roomCode || "ROOM",
                    practice: !!d.practice
                });
                if (d.players) applyRemotePlayers(d.players);
                if (d.level) {
                    const lv = parseInt(d.level, 10);
                    if (lv) { currentLevel = lv; }
                }
                return;
            }

            if (d.type === "tg_players"){
                applyRemotePlayers(d.players || {});
                return;
            }

            if (d.type === "tg_level"){
                const lv = parseInt(d.level, 10);
                if (lv && lv !== currentLevel){
                    currentLevel = lv;
                    loadLevel(currentLevel);
                }
                return;
            }

            if (d.type === "tg_buttons"){
                applyButtons(d.buttons || {});
                return;
            }

            if (d.type === "tg_button"){
                if (gameObjects?.buttons && gameObjects.buttons[d.idx]){
                    gameObjects.buttons[d.idx].pressed = !!d.pressed;
                    updateDoors();
                    updateBridges();
                    updateLifts();
                }
                return;
            }

            if (d.type === "tg_push"){
                const to = String(d.to || "");
                if (to && mySessionId && to !== mySessionId) return;
                const dx = clamp(Number(d.dx) || 0, -10, 10);
                if (!dx) return;
                // Apply a small horizontal impulse so the pushed player actually moves
                localPlayer.x += dx;
                localPlayer.vx = clamp((localPlayer.vx || 0) + dx * 0.55, -8, 8);
                try{ sfxPush(); }catch(_){ }
                bridgeSendState(true);
                return;
            }

            if (d.type === "tg_reset"){
                showDeathEffect(()=> resetMap());
                return;
            }
        });

// í˜ì´ì§€ ë¡œë“œì‹œ ì €ì¥ëœ ì´ë¦„ ë³µì›
        const savedName = localStorage.getItem('playerName');
        if (savedName) {
            document.getElementById('playerName').value = savedName;
        }
        
        document.getElementById('playerName').addEventListener('change', (e) => {
            localStorage.setItem('playerName', e.target.value);
        });
    </script>

<script>
(function(){
  function ping(){
    try{
      if (window.parent && window.parent !== window){
        window.parent.postMessage({ type: "tg_iframe_tap" }, "*");
      }
    }catch(e){}
  }
  window.addEventListener("pointerdown", ping, { passive: true });
  window.addEventListener("touchstart", ping, { passive: true });
  window.addEventListener("mousedown", ping, { passive: true });
})();
</script>

</body>
</html>
