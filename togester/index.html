<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no, maximum-scale=1.0">
    <title>ğŸ¹ íˆ¬ê²ŒìŠ¤í„° - í˜‘ë™ í”Œë«í¼ ê²Œì„</title>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Jua&family=Black+Han+Sans&display=swap');
        
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
            touch-action: none;
            -webkit-touch-callout: none;
            -webkit-user-select: none;
            user-select: none;
        }
        
        body {
            background: linear-gradient(135deg, #1a1a2e 0%, #16213e 50%, #0f3460 100%);
            min-height: 100vh;
            font-family: 'Jua', sans-serif;
            overflow: hidden;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
        }
        
        #lobby {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            z-index: 1000;
            padding: 20px;
        }
        
        #lobby.hidden {
            display: none;
        }
        
        .lobby-title {
            font-family: 'Black Han Sans', sans-serif;
            font-size: clamp(2rem, 8vw, 4rem);
            color: #fff;
            text-shadow: 4px 4px 0 #e94560, 8px 8px 0 rgba(0,0,0,0.2);
            margin-bottom: 10px;
            animation: bounce 1s ease infinite;
        }
        
        @keyframes bounce {
            0%, 100% { transform: translateY(0); }
            50% { transform: translateY(-10px); }
        }
        
        .lobby-subtitle {
            color: rgba(255,255,255,0.9);
            font-size: clamp(0.9rem, 3vw, 1.2rem);
            margin-bottom: 30px;
        }
        
        .cat-parade {
            display: flex;
            gap: 15px;
            margin-bottom: 30px;
        }
        
        .cat-preview {
            width: 50px;
            height: 55px;
            animation: parade 0.5s ease infinite alternate;
        }
        
        .cat-preview:nth-child(2) { animation-delay: 0.1s; }
        .cat-preview:nth-child(3) { animation-delay: 0.2s; }
        .cat-preview:nth-child(4) { animation-delay: 0.3s; }
        
        @keyframes parade {
            from { transform: translateY(0) rotate(-5deg); }
            to { transform: translateY(-10px) rotate(5deg); }
        }
        
        .input-group {
            margin-bottom: 15px;
            width: 100%;
            max-width: 300px;
        }
        
        .input-group label {
            display: block;
            color: rgba(255,255,255,0.9);
            margin-bottom: 5px;
            font-size: 0.9rem;
        }
        
        .input-group input {
            width: 100%;
            padding: 12px 16px;
            border: none;
            border-radius: 25px;
            font-size: 1rem;
            font-family: 'Jua', sans-serif;
            background: rgba(255,255,255,0.95);
            box-shadow: 0 4px 15px rgba(0,0,0,0.2);
        }
        
        .btn {
            padding: 15px 40px;
            font-size: 1.1rem;
            font-family: 'Black Han Sans', sans-serif;
            border: none;
            border-radius: 30px;
            cursor: pointer;
            transition: all 0.3s ease;
            margin: 8px;
            box-shadow: 0 4px 15px rgba(0,0,0,0.3);
        }
        
        .btn-create {
            background: linear-gradient(135deg, #00b894 0%, #00cec9 100%);
            color: white;
        }
        
        .btn-join {
            background: linear-gradient(135deg, #e17055 0%, #d63031 100%);
            color: white;
        }
        
        .btn-guest {
            background: linear-gradient(135deg, #a29bfe 0%, #6c5ce7 100%);
            color: white;
            width: 100%;
            max-width: 280px;
        }
        
        .btn:hover {
            transform: translateY(-3px) scale(1.05);
            box-shadow: 0 8px 25px rgba(0,0,0,0.4);
        }
        
        .btn:active {
            transform: translateY(0) scale(0.98);
        }
        
        #gameContainer {
            position: relative;
            width: 100%;
            height: 100vh;
            display: flex;
            flex-direction: column;
        }
        
        #gameHeader {
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            padding: 8px 10px;
            background: rgba(0,0,0,0.5);
            backdrop-filter: blur(10px);
            display: flex;
            justify-content: space-between;
            align-items: center;
            gap: 8px;
            flex-wrap: nowrap;
            z-index: 100;
        }

        #gameHeader > * { white-space: nowrap; }

        .header-right{
            display:flex;
            align-items:center;
            gap:8px;
            flex-wrap:nowrap;
        }

        .exit-btn{
            background: rgba(255,255,255,0.14);
            border: 1px solid rgba(255,255,255,0.22);
            color: #fff;
            padding: 6px 10px;
            border-radius: 14px;
            font-family: 'Jua', sans-serif;
            font-size: 0.85rem;
            cursor: pointer;
        }
        .exit-btn:active{ transform: scale(0.98); }

        @media (max-width: 420px){
            .room-code{ display:none; }
            .exit-btn{ padding: 6px 8px; font-size: 0.8rem; }
            .level-info{ font-size: 0.85rem; }
        }

        
        .room-code {
            background: rgba(255,255,255,0.2);
            padding: 5px 15px;
            border-radius: 20px;
            color: #fff;
            font-size: 0.9rem;
        }
        
        .level-info {
            color: #ffd700;
            font-size: 0.9rem;
        }
        
        .death-count {
            color: #ff6b6b;
            font-size: 0.82rem;
            background: rgba(255,107,107,0.2);
            padding: 3px 8px;
            border-radius: 10px;
        }
        
        #gameCanvas {
            flex: 1;
            width: 100%;
        }
        
        #playerList {
            position: absolute;
            top: 60px;
            right: 10px;
            background: rgba(0,0,0,0.6);
            backdrop-filter: blur(5px);
            padding: 10px;
            border-radius: 10px;
            z-index: 100;
        }
        
        .player-item {
            display: flex;
            align-items: center;
            gap: 8px;
            margin: 5px 0;
            color: white;
            font-size: 0.85rem;
        }
        
        .player-dot {
            width: 12px;
            height: 12px;
            border-radius: 50%;
        }
        
        #controls-hint {
            position: absolute;
            bottom: 20px;
            left: 50%;
            transform: translateX(-50%);
            background: rgba(0,0,0,0.7);
            color: white;
            padding: 10px 20px;
            border-radius: 20px;
            font-size: 0.75rem;
            text-align: center;
            z-index: 100;
            opacity: 0.8;
            max-width: 90%;
            white-space: nowrap;
        }
        
        #winScreen {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0,0,0,0.8);
            display: none;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            z-index: 2000;
        }
        
        #winScreen.show {
            display: flex;
        }
        
        .win-text {
            font-family: 'Black Han Sans', sans-serif;
            font-size: clamp(2rem, 10vw, 5rem);
            color: #ffd700;
            text-shadow: 0 0 30px rgba(255,215,0,0.5);
            animation: pulse 0.5s ease infinite alternate;
        }
        
        @keyframes pulse {
            from { transform: scale(1); }
            to { transform: scale(1.1); }
        }
        
        .firebase-config {
            margin-top: 20px;
            padding: 15px;
            background: rgba(255,255,255,0.1);
            border-radius: 15px;
            max-width: 300px;
            width: 100%;
        }
        
        .firebase-config summary {
            color: rgba(255,255,255,0.8);
            cursor: pointer;
            font-size: 0.9rem;
        }
        
        .firebase-config input {
            width: 100%;
            padding: 8px 12px;
            margin: 5px 0;
            border: none;
            border-radius: 8px;
            font-size: 0.85rem;
            background: rgba(255,255,255,0.9);
        }
        
        .error-msg {
            color: #ff6b6b;
            background: rgba(255,107,107,0.2);
            padding: 10px;
            border-radius: 10px;
            margin-top: 10px;
            font-size: 0.9rem;
            display: none;
        }
        
        .error-msg.show {
            display: block;
        }
    

        /* Action buttons (right side) */
        #actionButtons{
            position: absolute;
            right: 14px;
            bottom: 92px;
            display: flex;
            flex-direction: column;
            gap: 10px;
            z-index: 200;
            pointer-events: auto;
        }
        .action-btn{
            width: 68px;
            height: 68px;
            border-radius: 18px;
            border: 1px solid rgba(255,255,255,0.22);
            background: rgba(255,255,255,0.16);
            color: #fff;
            font-family: 'Black Han Sans', sans-serif;
            font-size: 0.98rem;
            letter-spacing: 0.5px;
            display: flex;
            align-items: center;
            justify-content: center;
            backdrop-filter: blur(8px);
            -webkit-backdrop-filter: blur(8px);
            box-shadow: 0 8px 24px rgba(0,0,0,0.22);
            touch-action: manipulation;
            user-select: none;
        }
        .action-btn:active{
            transform: scale(0.96);
        }

        /* Screen shake on death */
        @keyframes tgShake {
            0% { transform: translate3d(0,0,0); }
            15% { transform: translate3d(-10px, 6px, 0); }
            30% { transform: translate3d(9px, -7px, 0); }
            45% { transform: translate3d(-8px, -5px, 0); }
            60% { transform: translate3d(7px, 6px, 0); }
            75% { transform: translate3d(-6px, 4px, 0); }
            100% { transform: translate3d(0,0,0); }
        }
        #gameContainer.screen-shake{
            animation: tgShake 260ms linear;
        }

    </style>
</head>
<body>
    <!-- ë¡œë¹„ í™”ë©´ -->
    <div id="lobby">
        <h1 class="lobby-title">ğŸ¹ íˆ¬ê²ŒìŠ¤í„°</h1>
        <p class="lobby-subtitle">ìµœëŒ€ 4ëª…ì´ í•¨ê»˜í•˜ëŠ” í˜‘ë™ í”Œë«í¼ ê²Œì„!</p>
        
        <div class="cat-parade">
            <svg class="cat-preview" viewBox="0 0 40 40">
                <circle cx="20" cy="22" r="16" fill="#ff6b6b"/>
                <circle cx="8" cy="10" r="6" fill="#ff6b6b"/>
                <circle cx="32" cy="10" r="6" fill="#ff6b6b"/>
                <circle cx="8" cy="10" r="3" fill="#ffb8b8"/>
                <circle cx="32" cy="10" r="3" fill="#ffb8b8"/>
                <circle cx="14" cy="20" r="2.5" fill="#2d3436"/>
                <circle cx="26" cy="20" r="2.5" fill="#2d3436"/>
                <circle cx="15" cy="19" r="1" fill="white"/>
                <circle cx="27" cy="19" r="1" fill="white"/>
                <ellipse cx="9" cy="26" rx="5" ry="4" fill="#ffb8b8" opacity="0.7"/>
                <ellipse cx="31" cy="26" rx="5" ry="4" fill="#ffb8b8" opacity="0.7"/>
            </svg>
            <svg class="cat-preview" viewBox="0 0 40 40">
                <circle cx="20" cy="22" r="16" fill="#4ecdc4"/>
                <circle cx="8" cy="10" r="6" fill="#4ecdc4"/>
                <circle cx="32" cy="10" r="6" fill="#4ecdc4"/>
                <circle cx="8" cy="10" r="3" fill="#ffb8b8"/>
                <circle cx="32" cy="10" r="3" fill="#ffb8b8"/>
                <circle cx="14" cy="20" r="2.5" fill="#2d3436"/>
                <circle cx="26" cy="20" r="2.5" fill="#2d3436"/>
                <circle cx="15" cy="19" r="1" fill="white"/>
                <circle cx="27" cy="19" r="1" fill="white"/>
                <ellipse cx="9" cy="26" rx="5" ry="4" fill="#ffb8b8" opacity="0.7"/>
                <ellipse cx="31" cy="26" rx="5" ry="4" fill="#ffb8b8" opacity="0.7"/>
            </svg>
            <svg class="cat-preview" viewBox="0 0 40 40">
                <circle cx="20" cy="22" r="16" fill="#ffe66d"/>
                <circle cx="8" cy="10" r="6" fill="#ffe66d"/>
                <circle cx="32" cy="10" r="6" fill="#ffe66d"/>
                <circle cx="8" cy="10" r="3" fill="#ffb8b8"/>
                <circle cx="32" cy="10" r="3" fill="#ffb8b8"/>
                <circle cx="14" cy="20" r="2.5" fill="#2d3436"/>
                <circle cx="26" cy="20" r="2.5" fill="#2d3436"/>
                <circle cx="15" cy="19" r="1" fill="white"/>
                <circle cx="27" cy="19" r="1" fill="white"/>
                <ellipse cx="9" cy="26" rx="5" ry="4" fill="#ffb8b8" opacity="0.7"/>
                <ellipse cx="31" cy="26" rx="5" ry="4" fill="#ffb8b8" opacity="0.7"/>
            </svg>
            <svg class="cat-preview" viewBox="0 0 40 40">
                <circle cx="20" cy="22" r="16" fill="#a29bfe"/>
                <circle cx="8" cy="10" r="6" fill="#a29bfe"/>
                <circle cx="32" cy="10" r="6" fill="#a29bfe"/>
                <circle cx="8" cy="10" r="3" fill="#ffb8b8"/>
                <circle cx="32" cy="10" r="3" fill="#ffb8b8"/>
                <circle cx="14" cy="20" r="2.5" fill="#2d3436"/>
                <circle cx="26" cy="20" r="2.5" fill="#2d3436"/>
                <circle cx="15" cy="19" r="1" fill="white"/>
                <circle cx="27" cy="19" r="1" fill="white"/>
                <ellipse cx="9" cy="26" rx="5" ry="4" fill="#ffb8b8" opacity="0.7"/>
                <ellipse cx="31" cy="26" rx="5" ry="4" fill="#ffb8b8" opacity="0.7"/>
            </svg>
        </div>
        
        <div class="input-group">
            <label>ë‹‰ë„¤ì„</label>
            <input type="text" id="playerName" placeholder="í–„ìŠ¤í„° ì´ë¦„ì„ ì…ë ¥í•˜ì„¸ìš”" maxlength="10">
        </div>
        
        <div class="input-group">
            <label>ë°© ì½”ë“œ (ì°¸ê°€ì‹œ)</label>
            <input type="text" id="roomCode" placeholder="ë°© ì½”ë“œ ì…ë ¥" maxlength="6" style="text-transform: uppercase;">
        </div>
        
        <div>
            <button class="btn btn-create" onclick="createRoom()">ğŸ  ë°© ë§Œë“¤ê¸°</button>
            <button class="btn btn-join" onclick="joinRoom()">ğŸšª ì°¸ê°€í•˜ê¸°</button>
        </div>
        
        <div style="margin-top: 15px;">
            <button class="btn btn-guest" onclick="startGuestMode()">ğŸ® í˜¼ì ì—°ìŠµí•˜ê¸°</button>
        </div>
        
        <div id="errorMsg" class="error-msg"></div>
    </div>
    
    <!-- ê²Œì„ í™”ë©´ -->
    <div id="gameContainer" style="display:none;">
        <div id="gameHeader">
            <span class="room-code" id="displayRoomCode">ë°©: ----</span>
            <span class="level-info" id="levelInfo">ë ˆë²¨ 1</span>
            <div class="header-right">
                <span class="death-count" id="deathCount">ğŸ’€ 0</span>
                <button class="exit-btn" id="exitBtn" type="button">ë‚˜ê°€ê¸°</button>
            </div>
        </div>
        
        <canvas id="gameCanvas"></canvas>
        
        <div id="playerList"></div>

        <div id="actionButtons" aria-label="ì•¡ì…˜ ë²„íŠ¼">
            <button id="pushBtn" class="action-btn" type="button" title="ì•ì— ìˆëŠ” ìºë¦­í„°ë¥¼ ë°€ê¸°">ë°€ê¸°</button>
            <button id="floorBtn" class="action-btn" type="button" title="ë°œ ì•„ë˜ì— ë°œíŒ ìƒì„±">ë°”ë‹¥ 0/2</button>
        </div>
        
        <div id="controls-hint">
            ëª¨ë°”ì¼: ì™¼/ì˜¤ í„°ì¹˜ ì´ë™ | ì–‘ìª½ í„°ì¹˜ ì í”„ Â· PC: â†â†’ ì´ë™ / Z ì í”„ / X ë°€ê¸° / C ë°”ë‹¥
        </div>
    </div>
    
    <!-- ìŠ¹ë¦¬ í™”ë©´ -->
    <div id="winScreen">
        <div class="win-text">ğŸ‰ ë ˆë²¨ í´ë¦¬ì–´! ğŸ‰</div>
        <div id="autoNextHint" style="color: #aaa; margin-top: 15px; font-size: 0.9rem;">ì ì‹œ í›„ ë‹¤ìŒ ë ˆë²¨ë¡œ...</div>
    </div>

    <!-- ë°°ê²½ìŒì•… (ê²Œì„ ì§„í–‰ ì¤‘ ë°˜ë³µ ì¬ìƒ) -->
    <audio id="bgm" src="togestermusic.mp3" loop preload="auto"></audio>
<script>
        // ==================== ì„¤ì • ====================
        // Firebase ì˜ì¡´ì„± ì œê±° (Colyseus/ë¶€ëª¨ ë¸Œë¦¿ì§€ë¡œ ë™ê¸°í™”)
        const EMBED = new URLSearchParams(location.search).get('embed') === '1';
        const EMBED_PRACTICE = EMBED && (new URLSearchParams(location.search).get('practice') === '1');
        function bridgeSend(type, payload){
            if (!EMBED) return;
            try { window.parent && window.parent.postMessage({ type, ...payload }, '*'); } catch(e){}
        }

        // ì„œë²„ì— í˜„ì¬ ë°œíŒ ìƒíƒœë¥¼ ì¬ìš”ì²­ (ì´ˆê¸° ë¡œë”© íƒ€ì´ë° ë©”ì‹œì§€ ìœ ì‹¤ ë°©ì§€)
        function requestFloorSync(){
            if (!EMBED || isGuestMode) return;
            bridgeSend('tg_sync', {});
        }

        // ==================== ê²Œì„ ìƒíƒœ ====================
        let db = null;
        let roomRef = null;
        let playerId = null;
        let roomId = null;
        let isHost = false;
        let isGuestMode = false;
        let currentLevel = 1;
        let levelClearLock = false; // ë ˆë²¨ í´ë¦¬ì–´ ì¤‘ë³µ íŠ¸ë¦¬ê±° ë°©ì§€
        
        const HAMSTER_COLORS = ['#ff6b6b', '#4ecdc4', '#ffe66d', '#a29bfe'];
        // ê¸°ë³¸ ìŠˆí¼ë§ˆë¦¬ì˜¤ ëŠë‚Œ(ìŠ¤ë¥´ë¥µ ë©ˆì¶¤/ë¶€ë“œëŸ¬ìš´ ê°€ì†, ê³µì¤‘ì œì–´ëŠ” ì•½ê°„ ì•½í•˜ê²Œ)
        // (ë‹¨ìœ„: px/frame @60fps)
        const PHYS_SCALE = 1.0;
        // ê¸°ë³¸ ìŠˆí¼ë§ˆë¦¬ì˜¤(SMB1) ëŠë‚Œ: ê³¼ì† ë°©ì§€ + ì‚´ì§ ë¯¸ë„ëŸ¬ì§(ìŠ¤í‚¤ë“œ) + ë‚™í•˜/ì í”„ ì™„ë§Œ
        // (ë‹¨ìœ„: px/frame @60fps)
        const GRAVITY = 0.32 * PHYS_SCALE;
        const MAX_FALL_SPEED = 6.9 * PHYS_SCALE;
        const MOVE_MAX_SPEED = 3.0 * PHYS_SCALE;
        const MOVE_ACCEL_GROUND = 0.30 * PHYS_SCALE;
        const MOVE_ACCEL_AIR = 0.20 * PHYS_SCALE;
        const MOVE_FRICTION_GROUND = 0.14 * PHYS_SCALE;
        const MOVE_FRICTION_AIR = 0.04 * PHYS_SCALE;
        const MOVE_SKID_DECEL = 0.60 * PHYS_SCALE;
        const JUMP_VELOCITY = -8.4 * PHYS_SCALE;
        // ê°€ë³€ ì í”„(ì§§ê²Œ ëˆ„ë¥´ë©´ ë‚®ê²Œ, ê¸¸ê²Œ ëˆ„ë¥´ë©´ ë†’ê²Œ)
        const JUMP_HOLD_MAX_MS = 150;
        const JUMP_HOLD_GRAVITY_MULT = 0.55;
        const JUMP_CUT_VY = -2.8 * PHYS_SCALE;
        const RESPAWN_COOLDOWN_MS = 1500; // 1.5ì´ˆ
        const PUSH_IMPULSE_X = 16;
        const PUSH_IMPULSE_Y = -14;
        const PUSH_HITBOX_OFFSET_PX = 10; // player front edge +10px
        const PUSH_HITBOX_WIDTH = 140; // big hitbox (wide)
        const PUSH_HITBOX_HEIGHT = 44;
        const PUSH_HITBOX_Y_OFFSET = 6; // lower band (avoid hitting above)
        const FLOOR_COOLDOWN_MS = 220;
        const PUSH_ANIM_MS = 180; // push animation duration
        // Player-vs-player collision box is slimmer than the tile/platform box (matches sprite better)
        const PVP_PAD_X = 4;
        const PVP_W = 32;
        const PVP_H = 40;
        
        let localPlayer = {
            x: 100,
            y: 300,
            vx: 0,
            vy: 0,
            color: HAMSTER_COLORS[0],
            name: 'í–„ì°Œ',
            onGround: false,
            onButton: false,
            isDead: false,
            facing: 1,
            variant: 0,
            jumpUsed: false,
            deadAt: 0,
            nextRespawnAt: 0,
            pushAnimUntil: 0,
            knockbackUntil: 0,
            knockbackVx: 0,
            noHeadBlockUntil: 0,
            noHeadBlockSids: []
        };
        
        let players = {};
        let smoothedPlayers = {};
        let tgFloors = {}; // id -> platform (temporary floors)
        // ë°œíŒ(ì„ì‹œ ë°”ë‹¥) ë™ê¸°í™”ê°€ ì´ˆê¸° ë¡œë”© íƒ€ì´ë°ì— ìœ ì‹¤ë˜ì§€ ì•Šë„ë¡ ë²„í¼
        let pendingFloorFullSync = null; // Array<platform>
        let pendingFloorAdds = [];
        let pendingFloorRemoves = [];
        let pendingFloorAddSet = new Set();
        function flushPendingFloors(){
            if (!gameObjects || !gameObjects.platforms) return;
            if (pendingFloorFullSync){
                const arr = pendingFloorFullSync;
                pendingFloorFullSync = null;
                clearAllFloors();
                for (const pl of arr) addFloorPlatform(pl);
            }
            if (pendingFloorAdds.length){
                const arr = pendingFloorAdds.splice(0);
                pendingFloorAddSet.clear();
                for (const pl of arr) addFloorPlatform(pl);
            }
            if (pendingFloorRemoves.length){
                const arr = pendingFloorRemoves.splice(0);
                for (const rm of arr){
                    if (rm && Array.isArray(rm.ids)){
                        rm.ids.forEach(id => removeFloorById(id));
                    }else if (rm && rm.owner){
                        removeFloorsByOwner(rm.owner);
                    }
                }
            }
        }
        let tgFloorSeq = 0;
        let lastFloorAt = 0;
        // ë°œíŒ ìƒì„± ì œí•œ: "ë¼ìš´ë“œë‹¹ 2ê°œ" -> "ëª©ìˆ¨(ë¦¬ìŠ¤í°)ë‹¹ 2ê°œ"
        const FLOOR_LIMIT_PER_LIFE = 2;
        let floorUsedThisLife = 0;
        let lastPushAt = 0;

        // ë„¤íŠ¸ì›Œí¬ ë³´ê°„ìš© íˆìŠ¤í† ë¦¬ ë²„í¼ (ìƒëŒ€ ì›€ì§ì„ ëŠê¹€ ì™„í™”)
        let remoteHistory = {}; // { sid: [{t,x,y,vx,vy,isDead,color,name}, ...] }
        const NET_INTERP_DELAY_MS = 70; // ì§€ì—°ì„ ì¤„ì—¬ ë°€ê¸°/ì¶©ëŒ ë°˜ì‘ì´ ë” ì¦‰ê°ì ìœ¼ë¡œ ë³´ì´ê²Œ
        const NET_MAX_HISTORY_MS = 2000;
        let gameObjects = [];
        let canvas, ctx;
        let cameraX = 0;
        let cameraY = 0;
        let stageBounds = { minX: 0, maxX: 1200, minY: 0, maxY: 1000 };
        let deathCount = 0; // í˜„ì¬ ë ˆë²¨ ì‚¬ë§ íšŸìˆ˜
        let gameRunning = false;
        let rafId = null;
        
        // í„°ì¹˜ ìƒíƒœ
        let touches = {};

        // ê°€ë³€ ì í”„ ì…ë ¥ ìƒíƒœ
        let jumpKeyDown = false;
        let jumpTouchDown = false;
        function isJumpHeldNow(){ return !!jumpKeyDown || !!jumpTouchDown; }
        function handleJumpRelease(){
            try{
                if (!localPlayer) return;
                // early-release jump cut (SMB1 ëŠë‚Œ)
                if ((localPlayer.vy || 0) < 0 && (localPlayer.vy || 0) < JUMP_CUT_VY){
                    localPlayer.vy = JUMP_CUT_VY;
                }
                localPlayer.jumpHolding = false;
            }catch(_){ }
        }
        let moveDirection = 0; // -1: ì™¼ìª½, 0: ì •ì§€, 1: ì˜¤ë¥¸ìª½
        
        // ==================== ì‚¬ìš´ë“œ ì‹œìŠ¤í…œ ====================
        let audioCtx = null;

        // ë°°ê²½ìŒì•… (ì²¨ë¶€ mp3) - ê²Œì„ ì§„í–‰ ì¤‘ ë°˜ë³µ ì¬ìƒ
        let bgmEl = null;
        let bgmWanted = false;

        function initBGM() {
            if (!bgmEl) bgmEl = document.getElementById('bgm');
            if (bgmEl) {
                bgmEl.loop = true;
                bgmEl.preload = 'auto';
                // ê¸°ë³¸ ë³¼ë¥¨ (ë„ˆë¬´ í¬ì§€ ì•Šê²Œ)
                if (typeof bgmEl.volume === 'number') bgmEl.volume = 0.5;
            }
        }

        async function startBGM() {
            initBGM();
            if (!bgmEl) return;
            bgmWanted = true;
            try {
                await bgmEl.play();
            } catch (e) {
                // ìë™ì¬ìƒ ì œí•œ: ì²« ì…ë ¥ ì‹œ ì¬ì‹œë„
            }
        }

        function stopBGM() {
            bgmWanted = false;
            if (!bgmEl) return;
            try {
                bgmEl.pause();
                bgmEl.currentTime = 0;
            } catch (e) {}
        }

        // ì‚¬ìš©ì ì…ë ¥ì´ ë°œìƒí•˜ë©´ ì˜¤ë””ì˜¤ ì»¨í…ìŠ¤íŠ¸/ë°°ê²½ìŒì•… ì¬ì‹œë„ (ìë™ì¬ìƒ ì œí•œ ëŒ€ì‘)
        (function attachBGMGestureRetry(){
            const tryStart = async () => {
                initAudio();
                initBGM();
                if (!bgmEl) return;
                if (!bgmWanted) return;
                if (!bgmEl.paused) return;
                try { await bgmEl.play(); } catch (e) { return; }
            };
            document.addEventListener('pointerdown', tryStart, { passive: true });
            document.addEventListener('touchstart', tryStart, { passive: true });
            document.addEventListener('keydown', tryStart);
        })();
        
        function initAudio() {
            if (!audioCtx) {
                audioCtx = new (window.AudioContext || window.webkitAudioContext)();
            }
            if (audioCtx.state === 'suspended') {
                audioCtx.resume();
            }
        }
        
        function playTone(frequency, duration, type = 'square', volume = 0.3, slide = 0) {
            if (!audioCtx) return;
            
            const oscillator = audioCtx.createOscillator();
            const gainNode = audioCtx.createGain();
            
            oscillator.connect(gainNode);
            gainNode.connect(audioCtx.destination);
            
            oscillator.type = type;
            oscillator.frequency.setValueAtTime(frequency, audioCtx.currentTime);
            
            if (slide !== 0) {
                oscillator.frequency.linearRampToValueAtTime(frequency + slide, audioCtx.currentTime + duration);
            }
            
            gainNode.gain.setValueAtTime(volume, audioCtx.currentTime);
            gainNode.gain.exponentialRampToValueAtTime(0.01, audioCtx.currentTime + duration);
            
            oscillator.start(audioCtx.currentTime);
            oscillator.stop(audioCtx.currentTime + duration);
        }
        
        // ì í”„ ì†Œë¦¬ - ê·€ì—¬ìš´ "ë¿…!"
        function sfxJump() {
            initAudio();
            playTone(400, 0.1, 'sine', 0.2, 400);
        }
        
        // ë²„íŠ¼ ëˆ„ë¦„ - ë°ì€ "ë”©!"
        function sfxButton() {
            initAudio();
            playTone(880, 0.1, 'sine', 0.2);
            setTimeout(() => playTone(1100, 0.15, 'sine', 0.15), 50);
        }
        
        // ë¬¸ ì—´ë¦¼ - ìƒìŠ¹ ë©œë¡œë””
        function sfxDoorOpen() {
            initAudio();
            playTone(440, 0.1, 'triangle', 0.15);
            setTimeout(() => playTone(550, 0.1, 'triangle', 0.15), 80);
            setTimeout(() => playTone(660, 0.15, 'triangle', 0.15), 160);
        }
        
        // ì‚¬ë§ - ìŠ¬í”ˆ í•˜ê°•ìŒ
        function sfxDeath() {
            initAudio();
            playTone(400, 0.15, 'square', 0.2, -200);
            setTimeout(() => playTone(200, 0.3, 'square', 0.15, -100), 150);
        }
        
        // ë ˆë²¨ í´ë¦¬ì–´ - ì¶•í•˜ ë©œë¡œë””
        function sfxLevelClear() {
            initAudio();
            const notes = [523, 659, 784, 1047]; // C5, E5, G5, C6
            notes.forEach((note, i) => {
                setTimeout(() => playTone(note, 0.15, 'sine', 0.2), i * 100);
            });
        }
        
        // ê²Œì„ í´ë¦¬ì–´ - ê¸´ ì¶•í•˜ ë©œë¡œë””
        function sfxGameClear() {
            initAudio();
            const notes = [523, 587, 659, 698, 784, 880, 988, 1047]; // C major scale
            notes.forEach((note, i) => {
                setTimeout(() => playTone(note, 0.2, 'sine', 0.25), i * 120);
            });
            setTimeout(() => {
                playTone(1047, 0.4, 'sine', 0.3);
                playTone(1319, 0.4, 'sine', 0.2);
                playTone(1568, 0.4, 'sine', 0.2);
            }, notes.length * 120);
        }
        
        // ê±·ê¸° ì†Œë¦¬ (ì‘ì€ ë°œì†Œë¦¬)
        let lastStepTime = 0;
        function sfxStep() {
            const now = Date.now();
            if (now - lastStepTime < 200) return; // 200msë§ˆë‹¤ í•œ ë²ˆ
            lastStepTime = now;
            initAudio();
            playTone(100 + Math.random() * 50, 0.05, 'sine', 0.05);
        }
        
        // ë°•ìŠ¤ ë°€ê¸° ì†Œë¦¬
        let lastPushTime = 0;
        function sfxPush() {
            const now = Date.now();
            if (now - lastPushTime < 150) return;
            lastPushTime = now;
            initAudio();
            playTone(150, 0.08, 'square', 0.1);
        }
        
        
               // ==================== ëª¨ë°”ì¼ ì„¸ë¡œ ì§„í–‰ ë ˆë²¨ ====================
        // 25ë¼ìš´ë“œ: ë§µ ë°˜ë³µ ì—†ì´, ë¼ìš´ë“œê°€ ì˜¬ë¼ê°ˆìˆ˜ë¡ í•¨ì •/í¼ì¦ ë‚œì´ë„ê°€ ì¦ê°€í•˜ë„ë¡ êµ¬ì„±
        // (ê¸°ì¡´: 8ê°œ ë§µ ë°˜ë³µ -> ê°œì„ : 25ê°œ ë§µì„ ê²°ì •ë¡ ì ìœ¼ë¡œ ìƒì„±)

        const TG_STAGE_W = 520;
        const TG_GROUND_Y = 2400;
        const TG_TOP_GOAL_Y = 90;

        function _lerp(a,b,t){ return a + (b-a)*t; }
        function _mulberry32(a){
            return function(){
                let t = a += 0x6D2B79F5;
                t = Math.imul(t ^ (t >>> 15), t | 1);
                t ^= t + Math.imul(t ^ (t >>> 7), t | 61);
                return ((t ^ (t >>> 14)) >>> 0) / 4294967296;
            };
        }
        function _rint(rng, a, b){
            a = Math.floor(a); b = Math.floor(b);
            return a + Math.floor(rng() * (b - a + 1));
        }
        function _rfloat(rng, a, b){ return a + rng() * (b - a); }
        function _pick(rng, arr){ return arr[Math.floor(rng() * arr.length)]; }

        function _addPlatform(platforms, x, y, w, h=20, color='#636e72'){
            platforms.push({ x: Math.round(x), y: Math.round(y), width: Math.round(w), height: Math.round(h), color });
        }

        function _buttonOn(platformY){
            // ë²„íŠ¼ì€ í”Œë«í¼ ìƒë‹¨ì— 'ì˜¬ë ¤ë†“ëŠ”' í˜•íƒœ (ê¸°ì¡´ ë§µê³¼ ë™ì¼í•œ ë°©ì‹)
            return Math.round(platformY - 12);
        }

        function _chunkStairs({rng, platforms, y, step, wMin, wMax}){
            // 3ë‹¨ ì§€ê·¸ì¬ê·¸
            const sides = [60, 260];
            let side = rng() < 0.5 ? 0 : 1;
            for (let i=0;i<3;i++){
                const w = _rint(rng, wMin, wMax);
                const x = sides[side] + _rint(rng, -15, 15);
                _addPlatform(platforms, clamp(x, 20, TG_STAGE_W - w - 20), y - i*step, w, 20);
                side = 1 - side;
            }
            return y - step*3;
        }

        function _chunkSpike({rng, platforms, spikes, y, step, wMin, wMax, diff}){
            // ì¤‘ì•™ ìŠ¤íŒŒì´í¬ + ì¢Œ/ìš° ë°œíŒ
            const y1 = y - step;
            const y2 = y - step*2;
            const leftW = _rint(rng, wMin, wMax);
            const rightW = _rint(rng, wMin, wMax);
            _addPlatform(platforms, 35, y1, leftW, 20);
            _addPlatform(platforms, TG_STAGE_W - 35 - rightW, y1, rightW, 20);
            _addPlatform(platforms, 120 + _rint(rng,-25,25), y2, _rint(rng, wMin, wMax), 20);

            const spikeW = Math.round(_lerp(160, 300, diff));
            const spikeX = Math.round((TG_STAGE_W - spikeW)/2 + _rint(rng, -20, 20));
            spikes.push({ x: clamp(spikeX, 30, TG_STAGE_W - spikeW - 30), y: y1 + 18, width: spikeW, height: 40 });
            if (diff > 0.55 && rng() < 0.55){
                const spikeW2 = Math.round(_lerp(120, 260, diff));
                const spikeX2 = _rint(rng, 40, TG_STAGE_W - spikeW2 - 40);
                spikes.push({ x: spikeX2, y: y2 + 18, width: spikeW2, height: 40 });
            }
            return y - step*3;
        }

        function _chunkDoor({rng, platforms, doors, buttons, y, step, wMin, wMax, diff}){
            // ì „ì²´ í­ ë¬¸ + ë²„íŠ¼(í˜‘ë™)
            const yApproach = y - step;
            const yDoor = y - step*2 + 10;
            // ì ‘ê·¼ ë°œíŒ
            _addPlatform(platforms, 120 + _rint(rng,-25,25), yApproach, _rint(rng, wMin, wMax), 20);
            // ë¬¸ (ì „ì²´ í­)
            doors.push({ x: 0, y: yDoor, width: TG_STAGE_W, height: 30, open: false, color: '#d63031' });
            // ë²„íŠ¼ ë°œíŒ
            const btnSideLeft = rng() < 0.5;
            const btnPlatW = _rint(rng, 140, 190);
            const btnPlatX = btnSideLeft ? 35 : (TG_STAGE_W - 35 - btnPlatW);
            const btnPlatY = yApproach + _rint(rng, 70, 110);
            _addPlatform(platforms, btnPlatX, btnPlatY, btnPlatW, 20);
            buttons.push({ x: btnSideLeft ? 55 : (TG_STAGE_W - 55 - 70), y: _buttonOn(btnPlatY), width: 70, height: 12, pressed: false, doorId: doors.length-1, color: '#e17055' });

            // ë¬¸ ìœ„ìª½ ì§„í–‰ ë°œíŒ
            const topW = _rint(rng, wMin, wMax);
            _addPlatform(platforms, 120 + _rint(rng,-25,25), yDoor - 90, topW, 20);

            // í›„ë°˜ ë‚œì´ë„: 2ë‹¨ ë¬¸
            if (diff > 0.72 && rng() < 0.5){
                const yDoor2 = yDoor - step - 10;
                doors.push({ x: 0, y: yDoor2, width: TG_STAGE_W, height: 30, open: false, color: '#c0392b' });
                const btnPlatY2 = yDoor - 40;
                const btnPlatX2 = btnSideLeft ? (TG_STAGE_W - 35 - btnPlatW) : 35;
                _addPlatform(platforms, btnPlatX2, btnPlatY2, btnPlatW, 20);
                buttons.push({ x: btnSideLeft ? (TG_STAGE_W - 55 - 70) : 55, y: _buttonOn(btnPlatY2), width: 70, height: 12, pressed: false, doorId: doors.length-1, color: '#fdcb6e' });
                _addPlatform(platforms, 140, yDoor2 - 90, _rint(rng, wMin, wMax), 20);
            }

            return y - step*3;
        }

        function _chunkBridge({rng, platforms, bridges, buttons, spikes, y, step, diff}){
            const yGap = y - step;
            _addPlatform(platforms, 40, yGap, 160, 20);
            _addPlatform(platforms, 320, yGap, 160, 20);
            bridges.push({ x: 200, y: yGap, width: 120, height: 20, color: '#00cec9', active: false });

            // ë²„íŠ¼ì€ ì•„ë˜ìª½ì—
            const btnPlatY = yGap + _rint(rng, 130, 170);
            const btnPlatX = rng() < 0.5 ? 60 : 300;
            _addPlatform(platforms, btnPlatX, btnPlatY, 160, 20);
            buttons.push({ x: btnPlatX + 45, y: _buttonOn(btnPlatY), width: 70, height: 12, pressed: false, bridgeId: bridges.length-1, color: '#00b894' });

            // ë°‘ì— ìŠ¤íŒŒì´í¬(ì¤‘ë°˜ ì´í›„)
            if (diff > 0.35){
                spikes.push({ x: 150, y: yGap + 60, width: 220, height: 40 });
            }

            // ìœ„ìª½ ì§„í–‰ ë°œíŒ
            _addPlatform(platforms, 140 + _rint(rng,-30,30), yGap - step, 240, 20);
            return y - step*3;
        }

        function _chunkLift({rng, platforms, lifts, buttons, spikes, y, step, diff}){
            // ë²„íŠ¼ ëˆ„ë¥´ëŠ” ë™ì•ˆë§Œ ì˜¬ë¼ê°€ëŠ” ë¦¬í”„íŠ¸
            const bottomY = y - _rint(rng, 0, 10);
            const topY = bottomY - Math.round(step * _lerp(2.1, 2.6, diff));
            // ì ‘ê·¼ ë°œíŒ
            _addPlatform(platforms, 70 + _rint(rng,-15,15), bottomY - step, 200, 20);
            // ë¦¬í”„íŠ¸
            lifts.push({ x: 360, y: bottomY, width: 120, height: 20, minY: topY, maxY: bottomY, speed: _lerp(2.6, 3.4, diff), color: '#6c5ce7' });
            // ë²„íŠ¼ ë°œíŒ
            const btnPlatY = bottomY + _rint(rng, 130, 170);
            _addPlatform(platforms, 50, btnPlatY, 170, 20);
            buttons.push({ x: 85, y: _buttonOn(btnPlatY), width: 70, height: 12, pressed: false, liftId: lifts.length-1, color: '#a29bfe' });
            // ë¦¬í”„íŠ¸ ìƒë‹¨ í•˜ì°¨ ë°œíŒ
            _addPlatform(platforms, 250 + _rint(rng,-20,20), topY - 60, 220, 20);

            // í›„ë°˜: ë¦¬í”„íŠ¸ ì•„ë˜ì— ìŠ¤íŒŒì´í¬ ì••ë°•
            if (diff > 0.6 && rng() < 0.65){
                spikes.push({ x: 250, y: bottomY + 45, width: 220, height: 40 });
            }

            return y - step*3;
        }

        function _chunkBox({rng, platforms, doors, buttons, boxes, spikes, y, step, diff}){
            // ìƒì(ìˆ˜ë‹¨)ë¡œ ë²„íŠ¼ì„ ëˆŒëŸ¬ ë¬¸ì„ ì—´ê¸°
            const yApproach = y - step;
            _addPlatform(platforms, 120, yApproach, 260, 20);

            const yDoor = yApproach - 110;
            doors.push({ x: 0, y: yDoor, width: TG_STAGE_W, height: 30, open: false, color: '#d35400' });

            // ë²„íŠ¼ í¬ì¼“
            const pocketLeft = rng() < 0.5;
            const pocketX = pocketLeft ? 40 : 330;
            const pocketY = yApproach + _rint(rng, 120, 150);
            _addPlatform(platforms, pocketX, pocketY, 150, 20);
            buttons.push({ x: pocketX + 40, y: _buttonOn(pocketY), width: 70, height: 12, pressed: false, doorId: doors.length-1, color: '#fdcb6e' });

            // ìƒì (ì ‘ê·¼ ë°œíŒ ìœ„)
            boxes.push({ x: 240 + _rint(rng,-40,40), y: yApproach - 40, width: 40, height: 40 });

            // í•¨ì •: ìƒì ê¸¸ëª© ìŠ¤íŒŒì´í¬
            if (diff > 0.45){
                spikes.push({ x: 120 + _rint(rng,-30,30), y: yApproach + 35, width: 280, height: 40 });
            }

            // ë¬¸ ìœ„ ì§„í–‰ ë°œíŒ
            _addPlatform(platforms, 140 + _rint(rng,-25,25), yDoor - 90, 240, 20);
            return y - step*3;
        }

        function _chunkGap({rng, platforms, spikes, y, step, diff}){
            // í° ê°­: ì í”„ë§Œìœ¼ë¡œëŠ” ë¹¡ë¹¡(ë°”ë‹¥ 1~2ê°œ í™œìš©í•˜ë©´ ì‰¬ì›Œì§)
            const yGap = y - step;
            _addPlatform(platforms, 40, yGap, 170, 20);
            _addPlatform(platforms, 310, yGap, 170, 20);

            // ê°­ ì•„ë˜ì— ìŠ¤íŒŒì´í¬(ì¤‘ë°˜ ì´í›„)
            if (diff > 0.28){
                spikes.push({ x: 160, y: yGap + 70, width: 220, height: 40 });
            }

            // ìœ„ìª½ ì—°ê²° ë°œíŒ
            _addPlatform(platforms, 140 + _rint(rng,-35,35), yGap - step, 240, 20);
            return y - step*3;
        }

        function _seqForLevel(lv, rng){
            const pick = (arr)=>_pick(rng, arr);
            if (lv <= 3) return ['stairs','stairs','door','stairs','stairs'];
            if (lv <= 6) return ['stairs', pick(['door','bridge']), 'stairs', pick(['spike','gap']), 'stairs'];
            if (lv <= 10) return [pick(['door','bridge']), 'spike', pick(['lift','gap']), 'stairs', pick(['door','bridge'])];
            if (lv <= 15) return ['spike', pick(['door','box']), pick(['lift','bridge']), 'gap', 'stairs'];
            if (lv <= 20) return [pick(['door','box']), 'spike', pick(['lift','bridge']), pick(['door','gap']), 'spike'];
            return [pick(['box','door']), 'spike', pick(['lift','bridge']), 'box', 'spike'];
        }

        function _genLevel(lv){
            const rng = _mulberry32(0x51F15 + lv * 1337);
            const diff = clamp((lv - 1) / 24, 0, 1);

            const step = Math.round(_lerp(170, 135, diff));
            const wMax = Math.round(_lerp(290, 175, diff));
            const wMin = Math.round(_lerp(210, 120, diff));

            const platforms = [];
            const spikes = [];
            const doors = [];
            const buttons = [];
            const boxes = [];
            const lifts = [];
            const bridges = [];

            // ë°”ë‹¥
            platforms.push({ x: 0, y: TG_GROUND_Y, width: TG_STAGE_W, height: 70, color: '#2d3436' });

            // ì‹œì‘ ë†’ì´
            let y = 2230;

            // ì´ˆë°˜ ì•ˆì • ë°œíŒ 1~2ê°œ
            for (let i=0;i<2;i++){
                const w = _rint(rng, wMin+30, wMax);
                const x = _rint(rng, 50, TG_STAGE_W - w - 50);
                _addPlatform(platforms, x, y - i*step, w, 20);
            }
            y -= step*2;

            const seq = _seqForLevel(lv, rng);
            for (const t of seq){
                if (t === 'stairs') y = _chunkStairs({rng, platforms, y, step, wMin, wMax});
                else if (t === 'spike') y = _chunkSpike({rng, platforms, spikes, y, step, wMin, wMax, diff});
                else if (t === 'door') y = _chunkDoor({rng, platforms, doors, buttons, y, step, wMin, wMax, diff});
                else if (t === 'bridge') y = _chunkBridge({rng, platforms, bridges, buttons, spikes, y, step, diff});
                else if (t === 'lift') y = _chunkLift({rng, platforms, lifts, buttons, spikes, y, step, diff});
                else if (t === 'box') y = _chunkBox({rng, platforms, doors, buttons, boxes, spikes, y, step, diff});
                else if (t === 'gap') y = _chunkGap({rng, platforms, spikes, y, step, diff});
                else y = _chunkStairs({rng, platforms, y, step, wMin, wMax});

                // ë¼ìš´ë“œê°€ ë†’ì„ìˆ˜ë¡ ì‰¬ëŠ” êµ¬ê°„ì´ ì§§ì•„ì§: ì¶”ê°€ ë°œíŒì„ ëœ ì¤Œ
                if (diff < 0.25 && rng() < 0.35){
                    const w = _rint(rng, wMin+40, wMax);
                    const x = _rint(rng, 60, TG_STAGE_W - w - 60);
                    _addPlatform(platforms, x, y, w, 20);
                    y -= step;
                }
            }

            // ìƒë‹¨ ì •ë¦¬ ë°œíŒ
            _addPlatform(platforms, 140, 220, 240, 20);
            _addPlatform(platforms, 120, 140, 280, 20);

            const spawn = { x: 120, y: 2320 };
            const goal  = { x: 200, y: TG_TOP_GOAL_Y, width: 110, height: 90 };

            return {
                spawn, goal,
                platforms,
                buttons,
                doors,
                spikes,
                boxes,
                lifts,
                bridges,
                message: ""
            };
        }

        const LEVELS = Array.from({ length: 25 }, (_, i) => _genLevel(i + 1));

// ==================== ë¼ìš´ë“œ/ë§µ ì²˜ë¦¬ ====================
        // 25ë¼ìš´ë“œ ê³ ì •: ë§µ ë°˜ë³µ ì—†ì´(LEVELS=25), ë¼ìš´ë“œ í‘œê¸°ë¡œ ì§„í–‰
        const TG_MAP_COUNT = LEVELS.length;
        const TG_MAX_ROUNDS = TG_MAP_COUNT;
        const TG_ROUND_MODE = true;
        function getLevelForRound(roundNum){
            const n = Math.max(1, parseInt(roundNum, 10) || 1);
            const idx = clamp(n - 1, 0, Math.max(0, TG_MAP_COUNT - 1));
            return LEVELS[idx];
        }

        // ==================== ì—ëŸ¬ í‘œì‹œ ====================
        function showError(msg, isError = true) {
            const el = document.getElementById('errorMsg');
            el.textContent = msg;
            el.className = 'error-msg show';
            el.style.color = isError ? '#ff6b6b' : '#00b894';
            el.style.background = isError ? 'rgba(255,107,107,0.2)' : 'rgba(0,184,148,0.2)';
            setTimeout(() => el.classList.remove('show'), 3000);
        }
        
        // ==================== ë°© ê´€ë¦¬ ====================
        function generateRoomCode() {
            const chars = 'ABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789';
            let code = '';
            for (let i = 0; i < 5; i++) {
                code += chars.charAt(Math.floor(Math.random() * chars.length));
            }
            return code;
        }

        // ==================== ì„ë² ë“œ ëª¨ë“œ(Colyseus ë¸Œë¦¿ì§€) ====================
        function startEmbedded(init){
            isGuestMode = !!init.practice || EMBED_PRACTICE;
            isHost = !!init.isHost;
            roomId = String(init.roomCode || 'ROOM');
            playerId = String(init.sessionId || ('p_' + Date.now()));
            localPlayer.name = String(init.nick || 'í–„ì°Œ').slice(0, 16);
            const seat = typeof init.seat === 'number' ? init.seat : 0;
            localPlayer.color = HAMSTER_COLORS[seat % HAMSTER_COLORS.length];
            localPlayer.variant = seat % 4;
            currentLevel = 1;
            try{ tgEnded = false; }catch(e){}
            startGame();
            // ì²« ìƒíƒœ ì „ì†¡
            bridgeSendState(true);
            // Request a floor sync snapshot (prevents missing early broadcasts)
            requestFloorSync();
        }

        // createRoom()/joinRoom()/Firebase ë¡œì§ ì œê±°: ì™¸ë¶€ ë¡œë¹„(Colyseus)ì—ì„œ ë°©/ì…ì¥ì„ ì²˜ë¦¬í•©ë‹ˆë‹¤.
        
        function startGuestMode() {
            const name = document.getElementById('playerName').value.trim() || 'í–„ì°Œ';
            
            isGuestMode = true;
            isHost = true;
            roomId = 'GUEST';
            playerId = 'guest_player';
            
            localPlayer.name = name;
            localPlayer.color = HAMSTER_COLORS[0];
            localPlayer.variant = 0;
            localPlayer.x = LEVELS[0].spawn.x;
            localPlayer.y = LEVELS[0].spawn.y;
            
            startGame();
        }
        
        function updatePlayerList() {
            const container = document.getElementById('playerList');
            let html = `<div class="player-item">
                <div class="player-dot" style="background:${localPlayer.color}"></div>
                <span>${localPlayer.name} ${isGuestMode ? '(ì—°ìŠµì¤‘)' : '(ë‚˜)'}</span>
            </div>`;
            
            if (!isGuestMode) {
                Object.values(players).forEach(p => {
                    html += `<div class="player-item">
                        <div class="player-dot" style="background:${p.color}"></div>
                        <span>${p.name}</span>
                    </div>`;
                });
            }
            
            container.innerHTML = html;
        }
        
        // ==================== ê²Œì„ ì‹œì‘ ====================
        function startGame() {
            document.getElementById('lobby').classList.add('hidden');
            document.getElementById('gameContainer').style.display = 'flex';
            document.getElementById('displayRoomCode').textContent = isGuestMode ? 'ì—°ìŠµ' : ('ë°©: ' + roomId);
            
            canvas = document.getElementById('gameCanvas');
            ctx = canvas.getContext('2d');
            
            // ì˜¤ë””ì˜¤ ì´ˆê¸°í™”
            initAudio();
            // ë°°ê²½ìŒì•… ì‹œì‘ (ìë™ì¬ìƒ ì œí•œ ì‹œ ì²« ì…ë ¥ì—ì„œ ì¬ì‹œë„)
            startBGM();
            
            resizeCanvas();
            window.addEventListener('resize', resizeCanvas);
            
            loadLevel(currentLevel);
            setupControls();
            setupActionButtons();
            updatePlayerList();
            
            // ë‚˜ê°€ê¸° ë²„íŠ¼
            const exitBtn = document.getElementById('exitBtn');
            if (exitBtn && !exitBtn._bound){
                exitBtn._bound = true;
                exitBtn.addEventListener('click', ()=>{
                    // ì„ë² ë“œ(ë°© ì•ˆ ì—°ìŠµ í¬í•¨): ë¶€ëª¨ì—ê²Œ ë‚˜ê°€ê¸° ì‹ í˜¸ë§Œ ë³´ëƒ„
                    if (EMBED){
                        try{ bridgeSend("tg_quit", { practice: !!isGuestMode }); }catch(e){}
                        try{ stopBGM(); }catch(e){}
                        gameRunning = false;
                        if (rafId) { try{ cancelAnimationFrame(rafId); }catch(e){} rafId = null; }
                        return;
                    }

                    // ë‹¨ë…/ì—°ìŠµ ëª¨ë“œëŠ” ì•ˆì „í•˜ê²Œ ìƒˆë¡œê³ ì¹¨(ì¤‘ë³µ ë¦¬ìŠ¤ë„ˆ ë°©ì§€)
                    try{ stopBGM(); }catch(e){}
                    location.reload();
                });
            }

            // ë£¨í”„ ì‹œì‘
            gameRunning = true;
            gameLoop();
        }
        
        function resizeCanvas() {
            canvas.width = window.innerWidth;
            canvas.height = window.innerHeight;
        }

        // ==================== ë ˆë²¨ ì•ˆì „ì¥ì¹˜ ====================
        // ì í”„ ë†’ì´ë¥¼ ë‚®ì¶˜ ìƒíƒœì—ì„œ "ë¬¸(ë²½)" ë’¤ìª½ì— ë²„íŠ¼ì´ ìˆì–´ ì•„ì˜ˆ ëª» ëˆ„ë¥´ëŠ” ìƒí™©ì„ ë°©ì§€í•œë‹¤.
        // - ìŠ¤í° ìœ„ì¹˜ ê¸°ì¤€ìœ¼ë¡œ ë¬¸ê³¼ ê°™ì€ í¸ì— ë²„íŠ¼ì´ í•˜ë‚˜ë„ ì—†ìœ¼ë©´,
        //   ìŠ¤í° ê·¼ì²˜ì— 2ì¸µ(ì‘ì€ ë°œíŒ 2ê°œ) + ë²„íŠ¼ì„ ì¶”ê°€ë¡œ ìƒì„±í•´ì„œ ì§„í–‰ ë¶ˆê°€ ìƒíƒœë¥¼ ì œê±°.
        function findGroundYAt(x) {
            // í•´ë‹¹ x ì•„ë˜ì—ì„œ ê°€ì¥ "ë‚®ì€"(yê°€ í°) í”Œë«í¼ yë¥¼ ì°¾ëŠ”ë‹¤.
            let groundY = null;
            for (const p of (gameObjects?.platforms || [])) {
                if (x >= p.x && x <= p.x + p.width) {
                    if (groundY === null || p.y > groundY) groundY = p.y;
                }
            }
            return (groundY === null) ? 400 : groundY;
        }

        function stageMaxX() {
            let mx = 1200;
            const objs = gameObjects || {};
            (objs.platforms || []).forEach(p => mx = Math.max(mx, p.x + p.width));
            (objs.doors || []).forEach(d => mx = Math.max(mx, d.x + d.width));
            if (objs.goal) mx = Math.max(mx, objs.goal.x + (objs.goal.width || 0));
            return mx;
        }

        function clamp(v, min, max) {
            if (max < min) return min;
            return Math.max(min, Math.min(v, max));
        }

        // Move value `v` towards `target` by at most `delta`.
        function approach(v, target, delta){
            if (v < target) return Math.min(target, v + delta);
            return Math.max(target, v - delta);
        }

        function computeStageBounds() {
            let minX = Infinity, minY = Infinity, maxX = -Infinity, maxY = -Infinity;
            const objs = gameObjects || {};

            const pushRect = (r) => {
                if (!r) return;
                const x = (typeof r.x === 'number') ? r.x : 0;
                const y = (typeof r.y === 'number') ? r.y : 0;
                const w = (typeof r.width === 'number') ? r.width : 0;
                const h = (typeof r.height === 'number') ? r.height : 0;
                minX = Math.min(minX, x);
                minY = Math.min(minY, y);
                maxX = Math.max(maxX, x + w);
                maxY = Math.max(maxY, y + h);
            };

            (objs.platforms || []).forEach(pushRect);
            (objs.doors || []).forEach(pushRect);
            (objs.buttons || []).forEach(pushRect);
            (objs.spikes || []).forEach(pushRect);
            (objs.boxes || []).forEach(pushRect);
            (objs.bridges || []).forEach(pushRect);

            // ë¦¬í”„íŠ¸ëŠ” ì´ë™ ë²”ìœ„ë¥¼ í¬í•¨
            (objs.lifts || []).forEach(l => {
                const x = (typeof l.x === 'number') ? l.x : 0;
                const w = (typeof l.width === 'number') ? l.width : 0;
                const h = (typeof l.height === 'number') ? l.height : 0;
                const y0 = (typeof l.y === 'number') ? l.y : 0;
                const minYv = (typeof l.minY === 'number') ? l.minY : y0;
                const maxYv = (typeof l.maxY === 'number') ? l.maxY : y0;
                pushRect({ x, y: Math.min(minYv, maxYv), width: w, height: Math.abs(maxYv - minYv) + h });
            });

            if (objs.goal) pushRect(objs.goal);

            if (!isFinite(minX) || !isFinite(minY) || !isFinite(maxX) || !isFinite(maxY)) {
                stageBounds = { minX: 0, maxX: 1200, minY: 0, maxY: 1000 };
                return stageBounds;
            }

            // íŒ¨ë”©
            const padX = 180;
            const padY = 220;
            minX = Math.max(0, minX - padX);
            minY = Math.max(0, minY - padY);
            maxX = maxX + padX;
            maxY = maxY + padY;

            stageBounds = { minX, maxX, minY, maxY };
            return stageBounds;
        }


        function ensureDoorButtonsAccessible(level) {
            if (!gameObjects?.doors || !gameObjects?.buttons) return;

            const spawnX = level.spawn.x;
            const mx = stageMaxX();

            gameObjects.doors.forEach((door, doorId) => {
                // í•´ë‹¹ doorIdë¥¼ ì œì–´í•˜ëŠ” ë²„íŠ¼ì´ ìˆëŠ” ê²½ìš°ë§Œ
                const related = gameObjects.buttons.filter(b => b.doorId === doorId);
                if (related.length === 0) return;

                const needLeft = spawnX < door.x;
                const needRight = spawnX > (door.x + door.width);
                if (!needLeft && !needRight) return;

                if (needLeft) {
                    const hasLeft = related.some(b => (b.x + b.width) <= (door.x - 5));
                    if (hasLeft) return;
                    addFallbackDoorButton(level, door, doorId, 'left', mx);
                } else if (needRight) {
                    const hasRight = related.some(b => b.x >= (door.x + door.width + 5));
                    if (hasRight) return;
                    addFallbackDoorButton(level, door, doorId, 'right', mx);
                }
            });
        }

        function addFallbackDoorButton(level, door, doorId, side, mx) {
            const groundY = findGroundYAt(level.spawn.x);
            const step = 70; // ì í”„(2/3) ê¸°ì¤€ìœ¼ë¡œ ì•ˆì •ì ìœ¼ë¡œ ì˜¤ë¥¼ ìˆ˜ ìˆëŠ” ë†’ì´
            const midY = Math.max(80, groundY - step);
            const topY = Math.max(60, groundY - step * 2);

            // ìŠ¤í° ê·¼ì²˜ì— ì‘ì€ 2ì¸µ ë°œíŒì„ ë§Œë“¤ê³  ìœ„ì¸µì— ë²„íŠ¼ ë°°ì¹˜
            let baseX;
            if (side === 'left') {
                baseX = level.spawn.x + 110;
                baseX = Math.min(baseX, door.x - 220);
                baseX = Math.max(30, baseX);
            } else {
                baseX = level.spawn.x - 250;
                baseX = Math.max(baseX, door.x + door.width + 60);
                baseX = Math.min(mx - 200, baseX);
            }

            // ë°œíŒ ì¶”ê°€ (ì¤‘ë³µ ìƒì„± ë°©ì§€: ê°™ì€ doorId fallbackì´ ì´ë¯¸ ìˆìœ¼ë©´ skip)
            if (gameObjects.buttons.some(b => b.doorId === doorId && b.fallback)) return;

            gameObjects.platforms.push(
                { x: baseX, y: midY, width: 150, height: 20, color: '#636e72' },
                { x: baseX + 20, y: topY, width: 120, height: 20, color: '#636e72' }
            );

            gameObjects.buttons.push({
                x: baseX + 50,
                y: topY - 20,
                width: 60,
                height: 20,
                color: door.color || '#e17055',
                doorId,
                pressed: false,
                fallback: true
            });
        }
        
        function loadLevel(levelNum) {
            resetFloorQuotaLocal();
            const lvNum = Math.max(1, parseInt(levelNum, 10) || 1);
            if (lvNum > TG_MAX_ROUNDS) {
                // ëª¨ë“  ë ˆë²¨ í´ë¦¬ì–´
                document.getElementById('winScreen').querySelector('.win-text').textContent = 'ğŸŠ ê²Œì„ í´ë¦¬ì–´! ğŸŠ';
                document.getElementById('autoNextHint').style.display = 'none';
                document.getElementById('winScreen').classList.add('show');
                sfxGameClear();
                // ë©€í‹° ì„ë² ë“œ: ì„±ê³µ -> ë¶€ëª¨/ì„œë²„ë¡œ ê²°ê³¼ ì „ì†¡ (ìë™ ëŒ€ê¸°ì‹¤ ë³µê·€)
                bridgeSendOver(true, "game_clear");
                return;
            }
            const level = getLevelForRound(lvNum);
            if (!level) {
                // ë°©ì–´ ì½”ë“œ: ë ˆë²¨ ë°ì´í„°ê°€ ì—†ìœ¼ë©´ í´ë¦¬ì–´ ì²˜ë¦¬
                document.getElementById('winScreen').querySelector('.win-text').textContent = 'ğŸŠ ê²Œì„ í´ë¦¬ì–´! ğŸŠ';
                document.getElementById('autoNextHint').style.display = 'none';
                document.getElementById('winScreen').classList.add('show');
                sfxGameClear();
                bridgeSendOver(true, "game_clear");
                return;
            }
            
            document.getElementById('autoNextHint').style.display = 'block';
            document.getElementById('winScreen').querySelector('.win-text').textContent = 'ğŸ‰ ë ˆë²¨ í´ë¦¬ì–´! ğŸ‰';
            const label = TG_ROUND_MODE
                ? (isGuestMode ? `ì—°ìŠµ Â· ë¼ìš´ë“œ ${lvNum}/${TG_MAX_ROUNDS}` : `ë¼ìš´ë“œ ${lvNum}/${TG_MAX_ROUNDS}`)
                : (isGuestMode ? `ì—°ìŠµ Â· ë ˆë²¨ ${lvNum}` : `ë ˆë²¨ ${lvNum}`);
            document.getElementById('levelInfo').textContent = label;
            document.getElementById('winScreen').classList.remove('show');
            levelClearLock = false;
            
            // ê²Œì„ ì˜¤ë¸Œì íŠ¸ ì´ˆê¸°í™”
            gameObjects = {
                platforms: [...level.platforms],
                buttons: level.buttons.map(b => ({...b, pressed: false})),
                doors: level.doors.map(d => ({...d, open: false})),
                spikes: [...level.spikes],
                goal: {...level.goal},
                boxes: (level.boxes || []).map(b => ({...b, vx: 0, vy: 0})),
                lifts: (level.lifts || []).map(l => ({...l, y: (typeof l.y === 'number') ? l.y : (typeof l.maxY === 'number' ? l.maxY : 0)})),
                bridges: (level.bridges || []).map(b => ({...b, active: false}))
            };

            // ë™ì  ë°œíŒ(ë°”ë‹¥ ë²„íŠ¼) ì´ˆê¸°í™”
            clearAllFloors();
            flushPendingFloors();

            // ë²„íŠ¼ì´ ë¬¸ ë°˜ëŒ€í¸ì— ìˆì–´ ì§„í–‰ ë¶ˆê°€ê°€ ë˜ëŠ” ë ˆë²¨ ìë™ ë³´ì •
            ensureDoorButtonsAccessible(level);
            computeStageBounds();
            
            // í”Œë ˆì´ì–´ ìœ„ì¹˜ ì´ˆê¸°í™”
            const colorIndex = HAMSTER_COLORS.indexOf(localPlayer.color);
            localPlayer.x = level.spawn.x + (colorIndex * 50);
            localPlayer.y = level.spawn.y;
            localPlayer.vx = 0;
            localPlayer.vy = 0;
            localPlayer.isDead = false;
            localPlayer.jumpUsed = false;
            localPlayer.deadAt = 0;
            localPlayer.nextRespawnAt = 0;
            
            // ë„¤íŠ¸ì›Œí¬(ë¸Œë¦¿ì§€)ë¡œ ì´ˆê¸° ìœ„ì¹˜ ì „ì†¡
            bridgeSendState(true);

cameraX = 0;
            cameraY = 0;
        }
        
        function nextLevel() {
            if (isGuestMode) {
                currentLevel++;
                loadLevel(currentLevel);
                return;
            }

            const next = currentLevel + 1;

            // ì„ë² ë“œ ë©€í‹°: ëˆ„ê°€ ìš”ì²­í•´ë„ ì„œë²„ê°€ ë¸Œë¡œë“œìºìŠ¤íŠ¸ë¡œ ë™ê¸°í™”
            if (EMBED) {
                bridgeSend("tg_level", { level: next });
                return;
            }

            // ë¡œì»¬(ë¹„ì„ë² ë“œ) ëª¨ë“œ: ê¸°ì¡´ì²˜ëŸ¼ í˜¸ìŠ¤íŠ¸ë§Œ ì§„í–‰
            if (isHost) {
                currentLevel++;
                loadLevel(currentLevel);
            }
        }
        


        // ==================== ì•¡ì…˜/ì í”„/ë¶€í™œ/ë°œíŒ í—¬í¼ ====================
        function canJump(){
            return !localPlayer.isDead && !localPlayer.jumpUsed;
        }

        function anyTeammateAlive(){
            for (const p of Object.values(players || {})){
                if (p && !p.isDead) return true;
            }
            return false;
        }

        function doJump(){
            if (!canJump()) return;
            const now = performance.now();
            localPlayer.vy = JUMP_VELOCITY;
            localPlayer.jumpHolding = true;
            localPlayer.jumpStartAt = performance.now();
            localPlayer.onGround = false;
            localPlayer.jumpUsed = true;
            sfxJump();
            const launched = launchPlayersOnTop();
            if (launched && launched.length){
                localPlayer.noHeadBlockUntil = now + 180;
                localPlayer.noHeadBlockSids = launched;
            } else {
                localPlayer.noHeadBlockUntil = 0;
                localPlayer.noHeadBlockSids = [];
            }
        }

        function launchPlayersOnTop(){
            const launched = [];
            if (isGuestMode) return launched;
            const myL = localPlayer.x + PVP_PAD_X;
            const myR = myL + PVP_W;
            const myTop = localPlayer.y;
            for (const [sid, p] of Object.entries(players || {})){
                if (!p || p.isDead) continue;
                const pos = getRemotePosForLogic(sid, p || {});
                const px = (typeof pos.x === 'number') ? pos.x : (p.x || 0);
                const py = (typeof pos.y === 'number') ? pos.y : (p.y || 0);
                const prL = px + PVP_PAD_X;
                const prR = prL + PVP_W;
                const prBottom = py + PVP_H;
                const overlapX = (prR > myL + 2) && (prL < myR - 2);
                const onMyHead = (prBottom >= myTop - 6) && (prBottom <= myTop + 28);
                if (overlapX && onMyHead){
                    launched.push(sid);
                    // stronger lift so it visibly pops up
                    bridgeSendPush(sid, 0, -15);
                }
            }
            return launched;
        }

        function maybeHandleRespawn(){
            if (isGuestMode) return;
            if (!localPlayer.isDead) return;
            if (!anyTeammateAlive()) return;
            const now = performance.now();
            if (!localPlayer.deadAt) localPlayer.deadAt = now;
            if (now < (localPlayer.nextRespawnAt || 0)) return;
            if (now - localPlayer.deadAt < RESPAWN_COOLDOWN_MS) return;
            respawnLocal();
        }

        function respawnLocal(){
            // ëª©ìˆ¨(ë¦¬ìŠ¤í°)ë§ˆë‹¤ ë°œíŒ ì¿¼í„° ë¦¬ì…‹
            resetFloorQuotaLocal();
            const level = getLevelForRound(currentLevel);
            if (!level) return;
            const colorIndex = HAMSTER_COLORS.indexOf(localPlayer.color);
            localPlayer.x = level.spawn.x + (colorIndex * 50);
            localPlayer.y = level.spawn.y;
            localPlayer.vx = 0;
            localPlayer.vy = 0;
            localPlayer.isDead = false;
            localPlayer.jumpUsed = false;
            localPlayer.deadAt = 0;
            localPlayer.nextRespawnAt = 0;
            localPlayer.jumpUsed = false;
            localPlayer.deadAt = 0;
            localPlayer.nextRespawnAt = performance.now() + 120;
            bridgeSendState(true);
        }

        
        function updateFloorBtn(){
            const btn = document.getElementById('floorBtn');
            if (!btn) return;
            const used = Math.max(0, floorUsedThisLife|0);
            const can = (used < FLOOR_LIMIT_PER_LIFE) && !localPlayer.isDead;
            btn.textContent = `ë°”ë‹¥ ${Math.min(used, FLOOR_LIMIT_PER_LIFE)}/${FLOOR_LIMIT_PER_LIFE}`;
            // UX: 2ë²ˆ ì“°ë©´ ë‹¤ìŒ ë¼ìš´ë“œ/ë¦¬ìŠ¤í°ê¹Œì§€ ë²„íŠ¼ ìì²´ë¥¼ ë¹„í™œì„±í™”
            btn.disabled = !can;
            btn.style.pointerEvents = can ? 'auto' : 'none';
            btn.style.opacity = can ? '1' : '0.45';
        }

        function resetFloorQuotaLocal(){
            floorUsedThisLife = 0;
            updateFloorBtn();
        }

function setupActionButtons(){
            const pushBtn = document.getElementById('pushBtn');
            const floorBtn = document.getElementById('floorBtn');
            if (!pushBtn || !floorBtn) return;

            updateFloorBtn();

            if (!pushBtn._bound){
                pushBtn._bound = true;
                const h = (e)=>{
                    try{ e.preventDefault(); e.stopPropagation(); }catch(_){ }
                    initAudio();
                    doPushAction();
                };
                pushBtn.addEventListener('pointerdown', h, { passive: false });
            }
            if (!floorBtn._bound){
                floorBtn._bound = true;
                const h = (e)=>{
                    try{ e.preventDefault(); e.stopPropagation(); }catch(_){ }
                    initAudio();
                    createFloorUnderFoot();
                };
                floorBtn.addEventListener('pointerdown', h, { passive: false });
            }
        }

        function getPushHitboxRect(dir){
            // Requested: big hitbox located only in FRONT of me (never behind/above).
            const bodyL = localPlayer.x + PVP_PAD_X;
            const bodyR = bodyL + PVP_W;
            const x = (dir > 0)
                ? (bodyR + PUSH_HITBOX_OFFSET_PX)
                : (bodyL - PUSH_HITBOX_OFFSET_PX - PUSH_HITBOX_WIDTH);
            const y = localPlayer.y + PUSH_HITBOX_Y_OFFSET;
            return { x, y, width: PUSH_HITBOX_WIDTH, height: PUSH_HITBOX_HEIGHT };
        }

        
        function doPushAction(){
            if (isGuestMode) return;
            if (localPlayer.isDead) return;
            const now = performance.now();
            if (now - lastPushAt < 260) return;
            lastPushAt = now;

            // Push animation (works even in air)
            localPlayer.pushAnimUntil = now + PUSH_ANIM_MS;

            const dir = (moveDirection !== 0) ? moveDirection : (localPlayer.facing || 1);
            const hitbox = getPushHitboxRect(dir);
            const dx = (dir > 0) ? PUSH_IMPULSE_X : -PUSH_IMPULSE_X;

            const myTop = localPlayer.y;
            const myBottom = localPlayer.y + 40;
            const myCenterX = localPlayer.x + 20;

            let anyHit = false;
            for (const [sid, p] of Object.entries(players || {})) {
                if (!p || p.isDead) continue;
                const pos = getRemotePosForLogic(sid, p || {});
                const px = (typeof pos.x === 'number') ? pos.x : (p.x || 0);
                const py = (typeof pos.y === 'number') ? pos.y : (p.y || 0);

                // Exclude characters behind/above me (do not push people behind or on my head)
                const theirCenterX = px + 20;
                if (dir > 0) {
                    if (theirCenterX < myCenterX + 4) continue;
                } else {
                    if (theirCenterX > myCenterX - 4) continue;
                }

                // Above me (stacked/on-head) should NOT be pushed
                const theirBottom = py + PVP_H;
                if (theirBottom < myTop + 10) continue;
                // Too far below (different floor) also ignore
                if (py > myBottom - 8) continue;

                const remoteRect = { x: px + PVP_PAD_X, y: py, width: PVP_W, height: PVP_H };

                if (rectsOverlap(remoteRect, hitbox)) {
                    // Local prediction: show the pushed player moving immediately
                    // (network interpolation makes the real response arrive ~tens of ms later)
                    try{
                        if (!smoothedPlayers[sid]) smoothedPlayers[sid] = { x: px, y: py, vx: 0, vy: 0 };
                        smoothedPlayers[sid].x = px + dx * 0.7;
                        smoothedPlayers[sid].y = py + PUSH_IMPULSE_Y * 0.18;
                        const h = remoteHistory[sid];
                        if (h && Array.isArray(h)){
                            h.push({ t: performance.now(), x: smoothedPlayers[sid].x, y: smoothedPlayers[sid].y, vx: dx * 0.3, vy: 0 });
                        }
                    }catch(_){ }
                    bridgeSendPush(sid, dx, PUSH_IMPULSE_Y);
                    anyHit = true;
                }
            }
            if (anyHit) sfxPush();
            // Ensure our push pose replicates quickly
            bridgeSendState(true);
        }

        function addFloorPlatform(pl){
            if (!pl) return;
            const id = String(pl.id || '');
            if (!id) return;
            if (tgFloors[id]) return;

            // If the level isn't loaded yet, buffer this floor so we don't lose it.
            if (!gameObjects || !gameObjects.platforms){
                if (!pendingFloorAddSet.has(id)){
                    pendingFloorAddSet.add(id);
                    pendingFloorAdds.push(pl);
                }
                return;
            }

            const platform = {
                x: Number(pl.x) || 0,
                y: Number(pl.y) || 0,
                width: Number(pl.width) || 80,
                height: Number(pl.height) || 20,
                color: pl.color || '#2f3640',
                temp: true,
                owner: pl.owner || null,
                id
            };
            tgFloors[id] = platform;
            gameObjects.platforms.push(platform);
        }

        function removeFloorById(id){
            id = String(id || '');
            const pl = tgFloors[id];
            if (!pl) return;
            if (!gameObjects || !gameObjects.platforms){
                pendingFloorRemoves.push({ ids: [id] });
                return;
            }
            delete tgFloors[id];
            gameObjects.platforms = gameObjects.platforms.filter(p => !(p && p.temp && p.id === id));
        }

        function removeFloorsByOwner(owner){
            const oid = String(owner || '');
            const ids = [];
            for (const [id, pl] of Object.entries(tgFloors)){
                if (pl && String(pl.owner || '') === oid) ids.push(id);
            }
            for (const id of ids) removeFloorById(id);
        }

        function clearAllFloors(){
            tgFloors = {};
            if (!gameObjects || !gameObjects.platforms) return;
            gameObjects.platforms = gameObjects.platforms.filter(p => !(p && p.temp));
        }

        function createFloorUnderFoot(){
            if (localPlayer.isDead) return;

            // Hard gate: 2ë²ˆ ì‚¬ìš© í›„ì—” ë‹¤ìŒ ë¼ìš´ë“œ/ë¦¬ìŠ¤í° ì „ê¹Œì§€ ì…ë ¥ ìì²´ë¥¼ ë§‰ëŠ”ë‹¤.
            if ((floorUsedThisLife|0) >= FLOOR_LIMIT_PER_LIFE){
                updateFloorBtn();
                showError(`ì´ë²ˆ ëª©ìˆ¨ ë°”ë‹¥ì€ ${FLOOR_LIMIT_PER_LIFE}ê°œê¹Œì§€ë§Œ!`, true);
                return;
            }

            const now = performance.now();
            if (now - lastFloorAt < FLOOR_COOLDOWN_MS) return;
            lastFloorAt = now;

            const myOwner = (EMBED && mySessionId) ? mySessionId : (playerId || 'local');
            const w = 90;
            const h = 20;
            const x = (localPlayer.x + 20) - w/2;
            const y = (localPlayer.y + 40) + 4;
            const id = `${myOwner}:${Date.now().toString(36)}:${(tgFloorSeq++ % 9999)}`;

            const pl = { id, owner: myOwner, x, y, width: w, height: h, color: '#2f3640' };

            // Place locally immediately. If we receive the same id back from server, addFloorPlatform ignores duplicates.
            addFloorPlatform(pl);

            // Local quota count + UI lock
            floorUsedThisLife = (floorUsedThisLife|0) + 1;
            updateFloorBtn();

            // Multiplayer: broadcast the floor (quota is purely local lock)
            if (EMBED && !isGuestMode){
                try{ bridgeSend('tg_floor', { id: pl.id, owner: pl.owner, x: pl.x, y: pl.y, width: pl.width, height: pl.height, color: pl.color }); }catch(_){ }
            }
        }

        // ==================== í„°ì¹˜ ì»¨íŠ¸ë¡¤ ====================
        function setupControls() {
            // í„°ì¹˜ ì‹œì‘
            canvas.addEventListener('touchstart', (e) => {
                e.preventDefault();
                
                for (let touch of e.changedTouches) {
                    touches[touch.identifier] = {
                        x: touch.clientX,
                        y: touch.clientY,
                        startX: touch.clientX
                    };
                }
                
                // ë‘ ê°œ ì´ìƒ í„°ì¹˜ = ì í”„(ê¸¸ê²Œ ìœ ì§€í•˜ë©´ ë” ë†’ê²Œ)
                if (Object.keys(touches).length >= 2) {
                    if (!jumpTouchDown) {
                        jumpTouchDown = true;
                        doJump();
                    }
                } else {
                    jumpTouchDown = false;
                    
                    // ë‹¨ì¼ í„°ì¹˜ = ì´ë™ ë°©í–¥ ê²°ì •
                    updateMoveDirection();
                }
            });
            
            // í„°ì¹˜ ì´ë™
            canvas.addEventListener('touchmove', (e) => {
                e.preventDefault();
                
                for (let touch of e.changedTouches) {
                    if (touches[touch.identifier]) {
                        touches[touch.identifier].x = touch.clientX;
                        touches[touch.identifier].y = touch.clientY;
                    }
                }
                
                if (Object.keys(touches).length === 1) {
                    updateMoveDirection();
                }
            });
            
            // í„°ì¹˜ ì¢…ë£Œ
            canvas.addEventListener('touchend', (e) => {
                e.preventDefault();

                const before = Object.keys(touches).length;
                for (let touch of e.changedTouches) {
                    delete touches[touch.identifier];
                }
                const after = Object.keys(touches).length;
                if (before >= 2 && after < 2) {
                    jumpTouchDown = false;
                    handleJumpRelease();
                }

                if (after === 0) {
                    moveDirection = 0;
                } else if (Object.keys(touches).length === 1) {
                    updateMoveDirection();
                }
            });
            
            canvas.addEventListener('touchcancel', (e) => {
                e.preventDefault();
                const before = Object.keys(touches).length;
                for (let touch of e.changedTouches) {
                    delete touches[touch.identifier];
                }
                const after = Object.keys(touches).length;
                if (before >= 2 && after < 2) {
                    jumpTouchDown = false;
                    handleJumpRelease();
                }
                if (after === 0) {
                    moveDirection = 0;
                }
            });
            
            // ë§ˆìš°ìŠ¤ ì»¨íŠ¸ë¡¤ (ë°ìŠ¤í¬í†±) - í„°ì¹˜ì™€ ì™„ì „íˆ ë™ì¼í•œ ë°©ì‹
            // ì¢Œí´ë¦­ = ì†ê°€ë½1, ìš°í´ë¦­ = ì†ê°€ë½2
            canvas.addEventListener('mousedown', (e) => {
                e.preventDefault();
                initAudio();
                
                if (e.button === 0) { // ì™¼ìª½ í´ë¦­ = ì†ê°€ë½ 1
                    touches['mouseLeft'] = { x: e.clientX, y: e.clientY };
                } else if (e.button === 2) { // ì˜¤ë¥¸ìª½ í´ë¦­ = ì†ê°€ë½ 2
                    touches['mouseRight'] = { x: e.clientX, y: e.clientY };
                }
                
                // ë‘ ê°œ ì´ìƒ = ì í”„ (ìš°í´ë¦­ ìœ ì§€ ì‹œ ë” ë†’ê²Œ)
                if (Object.keys(touches).length >= 2) {
                    if (!jumpTouchDown) {
                        jumpTouchDown = true;
                        doJump();
                    }
                } else {
                    jumpTouchDown = false;
                    
                    updateMoveDirection();
                }
            });
            
            canvas.addEventListener('mousemove', (e) => {
                if (touches['mouseLeft']) {
                    touches['mouseLeft'] = { x: e.clientX, y: e.clientY };
                }
                if (touches['mouseRight']) {
                    touches['mouseRight'] = { x: e.clientX, y: e.clientY };
                }
                
                if (Object.keys(touches).length === 1) {
                    updateMoveDirection();
                }
            });
            
            canvas.addEventListener('mouseup', (e) => {
                const before = Object.keys(touches).length;
                if (e.button === 0) {
                    delete touches['mouseLeft'];
                } else if (e.button === 2) {
                    delete touches['mouseRight'];
                }
                const after = Object.keys(touches).length;
                if (before >= 2 && after < 2) {
                    jumpTouchDown = false;
                    handleJumpRelease();
                }
                
                if (after === 0) {
                    moveDirection = 0;
                } else if (after === 1) {
                    updateMoveDirection();
                }
            });
            
            canvas.addEventListener('mouseleave', () => {
                const before = Object.keys(touches).length;
                delete touches['mouseLeft'];
                delete touches['mouseRight'];
                const after = Object.keys(touches).length;
                if (before >= 2 && after < 2) {
                    jumpTouchDown = false;
                    handleJumpRelease();
                }
                moveDirection = 0;
            });
            
            // ìš°í´ë¦­ ë©”ë‰´ ë¹„í™œì„±í™”
            canvas.addEventListener('contextmenu', (e) => {
                e.preventDefault();
            });
            
            // PC ë‹¨ì¶•í‚¤
            // â†â†’ ì´ë™ / Z ì í”„ / X ë°€ê¸° / C ë°”ë‹¥
            const shouldHandleKeys = () => {
                // ë¡œë¹„/ì…ë ¥ ì¤‘ì—ëŠ” ë¬´ì‹œ
                const lobby = document.getElementById('lobby');
                if (lobby && !lobby.classList.contains('hidden')) return false;
                const ae = document.activeElement;
                if (ae && (ae.tagName === 'INPUT' || ae.tagName === 'TEXTAREA' || ae.isContentEditable)) return false;
                return true;
            };

            document.addEventListener('keydown', (e) => {
                if (!shouldHandleKeys()) return;
                const code = e.code || '';

                if (code === 'ArrowLeft') { e.preventDefault(); moveDirection = -1; }
                if (code === 'ArrowRight') { e.preventDefault(); moveDirection = 1; }

                if (code === 'KeyZ') {
                    e.preventDefault();
                    jumpKeyDown = true;
                    if (!e.repeat) { initAudio(); doJump(); }
                }
                if (code === 'KeyX') {
                    e.preventDefault();
                    if (!e.repeat) { initAudio(); doPushAction(); }
                }
                if (code === 'KeyC') {
                    e.preventDefault();
                    if (!e.repeat) { initAudio(); createFloorUnderFoot(); }
                }
            });

            document.addEventListener('keyup', (e) => {
                if (!shouldHandleKeys()) return;
                const code = e.code || '';
                if (code === 'ArrowLeft' && moveDirection === -1) moveDirection = 0;
                if (code === 'ArrowRight' && moveDirection === 1) moveDirection = 0;
                if (code === 'KeyZ') {
                    jumpKeyDown = false;
                    handleJumpRelease();
                }
            });
        }
        
        function updateMoveDirection() {
            const touchList = Object.values(touches);
            if (touchList.length === 0) {
                moveDirection = 0;
                return;
            }
            
            const touch = touchList[0];
            const screenCenter = window.innerWidth / 2;
            
            // í™”ë©´ ì¤‘ì•™ ê¸°ì¤€ìœ¼ë¡œ ë°©í–¥ ê²°ì •
            if (touch.x < screenCenter) {
                moveDirection = -1;
            } else {
                moveDirection = 1;
            }
        }
        
        // ==================== ê²Œì„ ë¬¼ë¦¬ ====================
        function updatePhysics() {
            maybeHandleRespawn();
            if (localPlayer.isDead){
                moveDirection = 0;
                localPlayer.vx = 0;
                localPlayer.vy = 0;
                return;
            }
            // ê¸°ë¯¹ ì—…ë°ì´íŠ¸ (ë¦¬í”„íŠ¸/ë‹¤ë¦¬)
            updateLifts();
            updateBridges();
            // ì´ë™
            const _now = performance.now();
            const wasOnGround = !!localPlayer.onGround;
            let vx = (typeof localPlayer.vx === 'number') ? localPlayer.vx : 0;

            // Input acceleration / friction (Mario-like)
            if (moveDirection !== 0) {
                const desired = moveDirection * MOVE_MAX_SPEED;
                // skidding when reversing direction on ground
                const reversing = wasOnGround && (Math.sign(desired) !== Math.sign(vx)) && Math.abs(vx) > 0.5;
                const accel = reversing ? MOVE_SKID_DECEL : (wasOnGround ? MOVE_ACCEL_GROUND : MOVE_ACCEL_AIR);
                vx = approach(vx, desired, accel);
            } else {
                const fric = wasOnGround ? MOVE_FRICTION_GROUND : MOVE_FRICTION_AIR;
                vx = approach(vx, 0, fric);
            }

            if (Math.abs(vx) > 0.25) localPlayer.facing = vx < 0 ? -1 : 1;

            // Knockback window: pushed players keep their momentum briefly (enables chain pushing)
            if (_now < (localPlayer.knockbackUntil || 0)) {
                const kb = (typeof localPlayer.knockbackVx === 'number') ? localPlayer.knockbackVx : 0;
                if (Math.abs(kb) > 0.001) vx = kb;
                // decay
                localPlayer.knockbackVx = kb * 0.92;
                if (Math.abs(localPlayer.knockbackVx) < 0.25) {
                    localPlayer.knockbackUntil = 0;
                }
                if (Math.abs(vx) > 0.3) localPlayer.facing = vx < 0 ? -1 : 1;
            }
            localPlayer.vx = vx;

            // Push animation window
                        localPlayer.pushing = (_now < (localPlayer.pushAnimUntil || 0));
            
            // ê±·ê¸° íš¨ê³¼ìŒ (ë•…ì—ì„œ ì´ë™ ì¤‘ì¼ ë•Œë§Œ)
            if (Math.abs(vx) > 0.25 && wasOnGround) {
                sfxStep();
            }
            
            // ì¤‘ë ¥ (+ ê°€ë³€ ì í”„)
            // ì í”„ ì¤‘(ìƒìŠ¹ ì¤‘) ì í”„ë¥¼ ê³„ì† ëˆ„ë¥´ê³  ìˆìœ¼ë©´ ì¤‘ë ¥ì„ ì•½í•˜ê²Œ í•´ì„œ ë” ë†’ì´ ëœ¨ê²Œ í•¨
            // (SMB1 ëŠë‚Œ: ì§§ê²Œ ëˆ„ë¥´ë©´ ë‚®ê²Œ, ê¸¸ê²Œ ëˆ„ë¥´ë©´ ë†’ê²Œ)
            let g = GRAVITY;
            if (localPlayer.vy < 0) {
                const held = isJumpHeldNow();
                const jt = (performance.now() - (localPlayer.jumpStartAt || 0));
                if (localPlayer.jumpHolding && held && jt <= JUMP_HOLD_MAX_MS) {
                    g = GRAVITY * JUMP_HOLD_GRAVITY_MULT;
                } else {
                    localPlayer.jumpHolding = false;
                }
            } else {
                localPlayer.jumpHolding = false;
            }
            localPlayer.vy += g;
            if (localPlayer.vy > MAX_FALL_SPEED) localPlayer.vy = MAX_FALL_SPEED;
            
            // ìœ„ì¹˜ ì—…ë°ì´íŠ¸
            localPlayer.x += localPlayer.vx;
            localPlayer.y += localPlayer.vy;
            
            // í”Œë«í¼ ì¶©ëŒ
            localPlayer.onGround = false;
            
            for (let platform of solidPlatforms()) {
                if (checkCollision(localPlayer, platform)) {
                    resolveCollision(localPlayer, platform);
                }
            }
            
            // ë‹«íŒ ë¬¸ê³¼ ì¶©ëŒ
            for (let door of gameObjects.doors) {
                if (!door.open && checkCollision(localPlayer, door)) {
                    resolveCollision(localPlayer, door);
                }
            }

            // í”Œë ˆì´ì–´-í”Œë ˆì´ì–´ ì¶©ëŒ (ìš”ì²­ì‚¬í•­: ì˜† ì¶©ëŒ + ìœ„ì— ì˜¬ë¼íƒ€ê¸° ê°€ëŠ¥)
            if (!isGuestMode) {
                try {
                    Object.entries(players).forEach(([sid, p]) => {
                        if (!p || p.isDead) return;
                        const pos = getRemotePosForLogic(sid, p || {});
                        const px = (typeof pos.x === 'number') ? pos.x : (p.x || 0);
                        const py = (typeof pos.y === 'number') ? pos.y : (p.y || 0);
                        const remoteRect = { x: px + PVP_PAD_X, y: py, width: PVP_W, height: PVP_H };
                        const myRect = { x: localPlayer.x + PVP_PAD_X, y: localPlayer.y, width: PVP_W, height: PVP_H };

                        if (rectsOverlap(myRect, remoteRect)) {
                            // Side collision should "push" the other player (requested).
                            resolvePlayerPlayerCollision(localPlayer, remoteRect, sid);
                        }
                    });
                } catch(_){ }
            }

            // ì°©ì§€í•˜ë©´ ì í”„ ì‚¬ìš©ê¶Œ ë³µêµ¬ (ê³µì¤‘ì—ì„œ ì•„ì§ ì í”„ ì•ˆí–ˆìœ¼ë©´ 1íšŒ ê°€ëŠ¥)
            if (localPlayer.onGround) { localPlayer.jumpUsed = false; localPlayer.jumpHolding = false; }
            
            // ë°•ìŠ¤ ë¬¼ë¦¬
            for (let box of gameObjects.boxes) {
                // ë°•ìŠ¤ ì¤‘ë ¥
                box.vy += GRAVITY;
                if (box.vy > MAX_FALL_SPEED) box.vy = MAX_FALL_SPEED;
                
                // ë°•ìŠ¤ ìœ„ì¹˜ ì—…ë°ì´íŠ¸
                box.x += box.vx;
                box.y += box.vy;
                box.vx *= 0.8; // ë§ˆì°°
                
                // ë°•ìŠ¤-í”Œë«í¼ ì¶©ëŒ
                for (let platform of solidPlatforms()) {
                    if (checkBoxCollision(box, platform)) {
                        resolveBoxCollision(box, platform);
                    }
                }
                
                // ë°•ìŠ¤-ë¬¸ ì¶©ëŒ
                for (let door of gameObjects.doors) {
                    if (!door.open && checkBoxCollision(box, door)) {
                        resolveBoxCollision(box, door);
                    }
                }
            }
            
            // í”Œë ˆì´ì–´-ë°•ìŠ¤ ì¶©ëŒ (ë°€ê¸°)
            for (let box of gameObjects.boxes) {
                if (checkPlayerBoxCollision(localPlayer, box)) {
                    pushBox(localPlayer, box);
                }
            }
            
            // ë²„íŠ¼ ì²´í¬ (í”Œë ˆì´ì–´ ë˜ëŠ” ë°•ìŠ¤)
            gameObjects.buttons.forEach((button, idx) => {
                let somethingOnButton = false;
                
                // í”Œë ˆì´ì–´ê°€ ë²„íŠ¼ ìœ„ì— ìˆëŠ”ì§€
                const playerOnButton = localPlayer.x + 20 > button.x && 
                                localPlayer.x < button.x + button.width &&
                                localPlayer.y + 40 > button.y &&
                                localPlayer.y + 40 < button.y + button.height + 10;
                if (playerOnButton) somethingOnButton = true;
                
                // ë°•ìŠ¤ê°€ ë²„íŠ¼ ìœ„ì— ìˆëŠ”ì§€
                for (let box of gameObjects.boxes) {
                    const boxOnButton = box.x + box.width/2 > button.x && 
                                       box.x < button.x + button.width &&
                                       box.y + box.height > button.y &&
                                       box.y + box.height < button.y + button.height + 10;
                    if (boxOnButton) somethingOnButton = true;
                }
                
                // ë‹¤ë¥¸ í”Œë ˆì´ì–´ê°€ ë²„íŠ¼ ìœ„ì— ìˆëŠ”ì§€ (ë©€í‹°í”Œë ˆì´)
                if (!isGuestMode) {
                    Object.entries(players).forEach(([sid, p]) => {
                        const pos = getRemotePosForLogic(sid, p || {});
                        const px = (typeof pos.x === 'number') ? pos.x : (p.x || 0);
                        const py = (typeof pos.y === 'number') ? pos.y : (p.y || 0);
                        if (px + 20 > button.x && px < button.x + button.width &&
                            py + 40 > button.y && py + 40 < button.y + button.height + 10) {
                            somethingOnButton = true;
                        }
                    });
                }
                
                // ë²„íŠ¼ ìƒíƒœ ì—…ë°ì´íŠ¸
                if (somethingOnButton && !button.pressed) {
                    button.pressed = true;
                    sfxButton();
                    bridgeSend("tg_button", { idx, pressed: true });
                } else if (!somethingOnButton && button.pressed && !isGuestMode) {
                    // ë©€í‹° ëª¨ë“œì—ì„œë§Œ ë²„íŠ¼ í•´ì œ (ê²ŒìŠ¤íŠ¸ ëª¨ë“œëŠ” ë°•ìŠ¤ë¡œ ì˜êµ¬ ê³ ì •)
                    button.pressed = false;
                    bridgeSend("tg_button", { idx, pressed: false });
                }
            });
            
            localPlayer.onButton = gameObjects.buttons.some(btn => btn.pressed);
            
            updateDoors();
            updateBridges();
            updateLifts();
            
            // ì´ë¯¸ ì£½ì€ ìƒíƒœë©´ ì‚¬ë§ ì²˜ë¦¬ ìŠ¤í‚µ
            if (!localPlayer.isDead) {
                // ìŠ¤íŒŒì´í¬ ì¶©ëŒ (ì‚¬ë§)
                for (let spike of gameObjects.spikes) {
                    if (checkCollision(localPlayer, {...spike, height: 20})) {
                        onDeath();
                        return;
                    }
                }
                
                // ë‚™ì‚¬
                if (localPlayer.y > (stageBounds.maxY + 320)) {
                    onDeath();
                    return;
                }
            }
            
            // ê³¨ ì²´í¬
            const goal = gameObjects.goal;
            if (localPlayer.x + 20 > goal.x && localPlayer.x < goal.x + goal.width &&
                localPlayer.y + 40 > goal.y && localPlayer.y < goal.y + goal.height) {
                // 1ëª…ì´ë¼ë„ ë‹¿ìœ¼ë©´ ì „ì› ë‹¤ìŒ ë ˆë²¨ë¡œ (ì„œë²„ tg_level ë¸Œë¡œë“œìºìŠ¤íŠ¸)
                if (!levelClearLock) {
                    levelClearLock = true;
                    if (!document.getElementById('winScreen').classList.contains('show')) {
                        sfxLevelClear();
                        document.getElementById('winScreen').classList.add('show');
                    }

                    if (isGuestMode) {
                        setTimeout(() => { nextLevel(); }, 1500);
                    } else {
                        // ë©€í‹°: ëˆ„ê°€ ë„ì°©í•˜ë“  ì„œë²„ì— ë‹¤ìŒ ë ˆë²¨ ìš”ì²­
                        bridgeSend("tg_level", { level: currentLevel + 1 });
                        // í˜¹ì‹œ ë¸Œë¡œë“œìºìŠ¤íŠ¸ê°€ ëŠ¦ìœ¼ë©´ ì ê¸ˆ í•´ì œ(ì¬íŠ¸ë¦¬ê±° ê°€ëŠ¥)
                        setTimeout(() => { levelClearLock = false; }, 2000);
                    }
                }
            }

            // ë„¤íŠ¸ì›Œí¬(ë¸Œë¦¿ì§€)ë¡œ ìƒíƒœ ì „ì†¡
            bridgeSendState();
        }
        
        function updateDoors() {
            gameObjects.doors.forEach((door, idx) => {
                const button = gameObjects.buttons.find(b => b.doorId === idx);
                const wasOpen = door.open;
                door.open = button ? button.pressed : false;
                if (!wasOpen && door.open) {
                    sfxDoorOpen();
                }
            });
        }
        
        function onDeath() {
            localPlayer.isDead = true;
            deathCount++;
            updateDeathCountUI();
            sfxDeath();
            // ì‚¬ë§ ì‹œì  ê¸°ë¡ (ë¶€í™œ ì¿¨íƒ€ì„)
            const _now = performance.now();
            localPlayer.deadAt = _now;
            localPlayer.nextRespawnAt = _now + RESPAWN_COOLDOWN_MS;
            // ë‚´ ë°œíŒ(ë°”ë‹¥ ë²„íŠ¼) ì œê±°
            try{
                const _owner = (EMBED && mySessionId) ? mySessionId : (playerId || 'local');
                removeFloorsByOwner(_owner);
                if (EMBED && !isGuestMode){
                    try{ bridgeSend('tg_floor_remove', { owner: _owner }); }catch(_){ }
                }
            }catch(_){ }

            if (isGuestMode) {
                // ê²ŒìŠ¤íŠ¸ ëª¨ë“œ: ë°”ë¡œ ë§µ ì´ˆê¸°í™”
                showDeathEffect(() => {
                    resetMap();
                });
            } else {
                // ë©€í‹° í”Œë ˆì´: ì‚¬ë§ í™”ë©´ ì§„ë™
                showDeathEffect();

                // ë©€í‹° í”Œë ˆì´: ë¸Œë¦¿ì§€ë¡œ ì‚¬ë§ ìƒíƒœ ì „ì†¡
                bridgeSendState(true);

                // ëª¨ë“  í”Œë ˆì´ì–´ ì‚¬ë§ ì²´í¬
                checkAllDead();
            }
        }
        
        function updateDeathCountUI() {
            document.getElementById('deathCount').textContent = 'ğŸ’€ ' + deathCount;
        }
        
        function showDeathEffect(callback) {
            // ì‚¬ë§ ì—°ì¶œ: í™”ë©´ ë¹¨ê°›ê²Œ ëŒ€ì‹  ì ê¹ ì§„ë™(ì‰ã‚¤ã‚¯)
            const gc = document.getElementById('gameContainer');
            if (gc) {
                try{
                    gc.classList.remove('screen-shake');
                    // reflow to restart animation
                    void gc.offsetWidth;
                    gc.classList.add('screen-shake');
                    setTimeout(() => {
                        try{ gc.classList.remove('screen-shake'); }catch(_){ }
                    }, 280);
                }catch(_){ }
            }
            setTimeout(() => {
                if (callback) callback();
            }, 270);
        }
        
        function checkAllDead() {
            // ëª¨ë“  í”Œë ˆì´ì–´ê°€ ì‚¬ë§í–ˆëŠ”ì§€ í™•ì¸
            let allDead = localPlayer.isDead;
            
            Object.values(players).forEach(p => {
                if (!p.isDead) {
                    allDead = false;
                }
            });
            
            if (allDead && Object.keys(players).length > 0) {
                // ì„ë² ë“œ ë©€í‹°: ì „ì› ì‚¬ë§ = ì‹¤íŒ¨ -> ë¶€ëª¨/ì„œë²„ë¡œ ê²°ê³¼ ì „ì†¡
                if (EMBED && !isGuestMode) {
                    bridgeSendOver(false, "all_dead");
                    return;
                }
                // ê·¸ ì™¸(ë¡œì»¬/ê²ŒìŠ¤íŠ¸): í˜¸ìŠ¤íŠ¸ë§Œ ë§µ ë¦¬ì…‹ íŠ¸ë¦¬ê±°
                if (isHost) { bridgeSend("tg_reset", { t: Date.now() }); }
            } else if (allDead && Object.keys(players).length === 0) {
                // í˜¼ì í”Œë ˆì´ ì¤‘ì¸ ê²½ìš°(ì„ë² ë“œë©´ ì‹¤íŒ¨ë¡œ ì²˜ë¦¬)
                if (EMBED && !isGuestMode) {
                    bridgeSendOver(false, "all_dead");
                    return;
                }
                showDeathEffect(() => { resetMap(); });
            }
        }
        
        function resetMap() {
            resetFloorQuotaLocal();
            // ë§µ ì´ˆê¸°í™” (ë²„íŠ¼, ë¬¸ ìƒíƒœ ë¦¬ì…‹)
            loadLevel(currentLevel);
            localPlayer.isDead = false;
            localPlayer.jumpUsed = false;
            localPlayer.deadAt = 0;
            localPlayer.nextRespawnAt = 0;
            
            // ë¸Œë¦¿ì§€: ë¦¬ì…‹ ì „íŒŒ(í˜¸ìŠ¤íŠ¸ë§Œ)
            if (!isGuestMode && isHost) {
                bridgeSend("tg_reset", { t: Date.now() });
                gameObjects.buttons.forEach((btn, idx) => bridgeSend("tg_button", { idx, pressed: false }));
                bridgeSendState(true);
            }
        }
        
        function respawn() {
            // ê¸°ì¡´ respawnì€ ìœ„ì¹˜ë§Œ ë¦¬ì…‹ (ì‚¬ë§ ì—†ì´ ìœ„ì¹˜ ì¡°ì • í•„ìš”ì‹œ ì‚¬ìš©)
            const level = getLevelForRound(currentLevel);
            const colorIndex = HAMSTER_COLORS.indexOf(localPlayer.color);
            localPlayer.x = level.spawn.x + (colorIndex * 50);
            localPlayer.y = level.spawn.y;
            localPlayer.vx = 0;
            localPlayer.vy = 0;
        }
        
        function checkCollision(player, rect) {
            return player.x + 40 > rect.x &&
                   player.x < rect.x + rect.width &&
                   player.y + 40 > rect.y &&
                   player.y < rect.y + rect.height;
        }

        function rectsOverlap(a, b){
            return a.x < b.x + b.width &&
                   a.x + a.width > b.x &&
                   a.y < b.y + b.height &&
                   a.y + a.height > b.y;
        }
        
        function resolveCollision(player, rect) {
            // Resolve AABB collision for a 40x40 player box against a rect.
            const overlapX = Math.min(player.x + 40 - rect.x, rect.x + rect.width - player.x);
            const overlapY = Math.min(player.y + 40 - rect.y, rect.y + rect.height - player.y);
            if (overlapX < overlapY) {
                // left/right
                if (player.x + 20 < rect.x + rect.width / 2) {
                    player.x = rect.x - 40;
                } else {
                    player.x = rect.x + rect.width;
                }
                player.vx = 0;
            } else {
                // up/down
                if (player.y + 20 < rect.y + rect.height / 2) {
                    player.y = rect.y - 40;
                    player.onGround = true;
                    player.vy = 0;
                } else {
                    player.y = rect.y + rect.height;
                    player.vy = 0;
                }
            }
        }

        // í”Œë ˆì´ì–´-í”Œë ˆì´ì–´ ì¶©ëŒ í•´ê²° (ì˜† ì¶©ëŒ ì‹œ ìƒëŒ€ë¥¼ 'ë°€ê¸°')
        // NOTE: ê° í”Œë ˆì´ì–´ëŠ” ìì‹ ì˜ ìƒíƒœë§Œ ì„œë²„ë¡œ ì „ì†¡í•˜ë¯€ë¡œ,
        //       ë°€ë¦¼ì€ 'push impulse' ì´ë²¤íŠ¸ë¥¼ ìƒëŒ€ì—ê²Œ ì „ë‹¬í•´ ì ìš©í•©ë‹ˆë‹¤.
        function bridgeSendPush(toSid, dx, dy){
            if (!EMBED || isGuestMode) return;
            const sid = String(toSid || "");
            if (!sid || sid === mySessionId) return;
            const now = performance.now();
            if (!bridgeSendPush._last) bridgeSendPush._last = {};
            const last = bridgeSendPush._last[sid] || 0;
            if (now - last < 120) return; // throttle
            bridgeSendPush._last[sid] = now;

            const vx = clamp(Number(dx) || 0, -16, 16);
            const vy = clamp(Number(dy) || 0, -16, 16);
            if (!vx && !vy) return;
            bridgeSend("tg_push", { to: sid, dx: vx, dy: vy });
        }

        function resolvePlayerPlayerCollision(player, rect, remoteSid){
            // PvP collision uses a slimmer rect to match the 32px sprite body.
            const pRect = { x: player.x + PVP_PAD_X, y: player.y, width: PVP_W, height: PVP_H };

            const overlapX = Math.min(pRect.x + pRect.width - rect.x, rect.x + rect.width - pRect.x);
            const overlapY = Math.min(pRect.y + pRect.height - rect.y, rect.y + rect.height - pRect.y);

            if (overlapX < overlapY) {
                // Side collision: separate X but keep some velocity, and push the other player
                if (pRect.x < rect.x) {
                    pRect.x = rect.x - pRect.width;
                    player.x = pRect.x - PVP_PAD_X;
                    // If we're moving into them, send an impulse so they bounce forward.
                    if (player.vx > 0.35) bridgeSendPush(remoteSid, player.vx * 1.05, Math.abs(player.vx) > 2.0 ? -2.2 : 0);
                } else {
                    pRect.x = rect.x + rect.width;
                    player.x = pRect.x - PVP_PAD_X;
                    if (player.vx < -0.35) bridgeSendPush(remoteSid, player.vx * 1.05, Math.abs(player.vx) > 2.0 ? -2.2 : 0);
                }
                // Do not kill momentum completelyâ€”helps chain reactions feel physical.
                player.vx *= 0.45;
            } else {
                // Vertical collision: allow standing on top of others
                if (pRect.y < rect.y) {
                    player.y = rect.y - pRect.height;
                    player.onGround = true;
                    player.vy = 0;
                } else {
                    // When I jump while someone is stacked on my head, don't let their (slightly delayed)
                    // position cancel my jump. We already launch them upward; give a short grace window.
                    try{
                        const now = performance.now();
                        const blockUntil = player.noHeadBlockUntil || 0;
                        const list = player.noHeadBlockSids;
                        if (player.vy < -0.2 && now < blockUntil && Array.isArray(list) && list.indexOf(remoteSid) !== -1){
                            return;
                        }
                    }catch(_){ }

                    player.y = rect.y + rect.height;
                    player.vy = 0;
                }
            }
        }

        // ë°•ìŠ¤ ì¶©ëŒ ì²´í¬
        function checkBoxCollision(box, rect) {
            return box.x + box.width > rect.x &&
                   box.x < rect.x + rect.width &&
                   box.y + box.height > rect.y &&
                   box.y < rect.y + rect.height;
        }
        
        // ë°•ìŠ¤ ì¶©ëŒ í•´ê²°
        function resolveBoxCollision(box, rect) {
            const overlapX = Math.min(box.x + box.width - rect.x, rect.x + rect.width - box.x);
            const overlapY = Math.min(box.y + box.height - rect.y, rect.y + rect.height - box.y);
            
            if (overlapX < overlapY) {
                if (box.x < rect.x) {
                    box.x = rect.x - box.width;
                } else {
                    box.x = rect.x + rect.width;
                }
                box.vx = 0;
            } else {
                if (box.y < rect.y) {
                    box.y = rect.y - box.height;
                    box.vy = 0;
                } else {
                    box.y = rect.y + rect.height;
                    box.vy = 0;
                }
            }
        }
        
        // í”Œë ˆì´ì–´-ë°•ìŠ¤ ì¶©ëŒ ì²´í¬
        function checkPlayerBoxCollision(player, box) {
            return player.x + 40 > box.x &&
                   player.x < box.x + box.width &&
                   player.y + 40 > box.y &&
                   player.y < box.y + box.height;
        }
        
        // ë°•ìŠ¤ ë°€ê¸°
        function pushBox(player, box) {
            const overlapX = Math.min(player.x + 40 - box.x, box.x + box.width - player.x);
            const overlapY = Math.min(player.y + 40 - box.y, box.y + box.height - player.y);
            
            if (overlapX < overlapY) {
                // ì˜†ì—ì„œ ì¶©ëŒ - ë°•ìŠ¤ ë°€ê¸°
                sfxPush();
                if (player.x < box.x) {
                    box.vx = 3;
                    player.x = box.x - 40;
                } else {
                    box.vx = -3;
                    player.x = box.x + box.width;
                }
            } else {
                // ìœ„ì•„ë˜ ì¶©ëŒ
                if (player.y < box.y) {
                    // í”Œë ˆì´ì–´ê°€ ë°•ìŠ¤ ìœ„ì— ì°©ì§€
                    player.y = box.y - 40;
                    player.onGround = true;
                    player.vy = 0;
                } else {
                    // í”Œë ˆì´ì–´ê°€ ë°•ìŠ¤ ì•„ë˜ì—ì„œ ë¶€ë”ªí˜
                    player.y = box.y + box.height;
                    player.vy = 0;
                }
            }
        }
        
        

        // ===== ê¸°ë¯¹: ë¦¬í”„íŠ¸/ìƒì„±í˜• ë‹¤ë¦¬ =====
        function solidPlatforms() {
            const base = (gameObjects && gameObjects.platforms) ? gameObjects.platforms : [];
            const lifts = (gameObjects && gameObjects.lifts) ? gameObjects.lifts : [];
            const bridges = (gameObjects && gameObjects.bridges) ? gameObjects.bridges.filter(b => b.active) : [];
            return base.concat(lifts, bridges);
        }

        function updateLifts() {
            if (!gameObjects || !gameObjects.lifts) return;
            gameObjects.lifts.forEach((lift, idx) => {
                const btn = (gameObjects.buttons || []).find(b => b.liftId === idx);
                const active = btn ? !!btn.pressed : false;
                const minY = (typeof lift.minY === 'number') ? lift.minY : lift.y;
                const maxY = (typeof lift.maxY === 'number') ? lift.maxY : lift.y;
                const targetY = active ? minY : maxY;
                const speed = (typeof lift.speed === 'number') ? lift.speed : 2;
                const dy = targetY - lift.y;
                if (Math.abs(dy) <= speed) {
                    lift.y = targetY;
                } else {
                    lift.y += Math.sign(dy) * speed;
                }
            });
        }

        function updateBridges() {
            if (!gameObjects || !gameObjects.bridges) return;
            gameObjects.bridges.forEach((br, idx) => {
                const btn = (gameObjects.buttons || []).find(b => b.bridgeId === idx);
                br.active = btn ? !!btn.pressed : false;
            });
        }

// ==================== ë Œë”ë§ ====================
        function render() {
            // ë°°ê²½
            const gradient = ctx.createLinearGradient(0, 0, 0, canvas.height);
            gradient.addColorStop(0, '#1a1a2e');
            gradient.addColorStop(0.5, '#16213e');
            gradient.addColorStop(1, '#0f3460');
            ctx.fillStyle = gradient;
            ctx.fillRect(0, 0, canvas.width, canvas.height);
            
            // ì¹´ë©”ë¼ ë”°ë¼ê°€ê¸° (ëª¨ë°”ì¼ ì„¸ë¡œ ì§„í–‰: X/Y ëª¨ë‘ ì¶”ì )
            const targetCameraX = localPlayer.x - canvas.width / 2;
            const targetCameraY = localPlayer.y - canvas.height / 2;
            cameraX += (targetCameraX - cameraX) * 0.12;
            cameraY += (targetCameraY - cameraY) * 0.12;

            cameraX = clamp(cameraX, stageBounds.minX, stageBounds.maxX - canvas.width);
            cameraY = clamp(cameraY, stageBounds.minY, stageBounds.maxY - canvas.height);

            ctx.save();
            ctx.translate(-cameraX, -cameraY);
// ë°°ê²½ ë³„
            for (let i = 0; i < 50; i++) {
                const x = (i * 73 + cameraX * 0.1) % 2500 + cameraX;
                const y = (i * 47 + cameraY * 0.1) % 2500 + cameraY;
                ctx.fillStyle = `rgba(255,255,255,${0.3 + Math.sin(Date.now() / 1000 + i) * 0.2})`;
                ctx.beginPath();
                ctx.arc(x, y, 1 + Math.random(), 0, Math.PI * 2);
                ctx.fill();
            }
            
            // í”Œë«í¼
            gameObjects.platforms.forEach(p => {
                ctx.fillStyle = p.color;
                ctx.fillRect(p.x, p.y, p.width, p.height);
                
                // í•˜ì´ë¼ì´íŠ¸
                ctx.fillStyle = 'rgba(255,255,255,0.1)';
                ctx.fillRect(p.x, p.y, p.width, 3);
            });
            

            
            // ìƒì„±í˜• ë‹¤ë¦¬ (ë²„íŠ¼ ì—°ë™)
            (gameObjects.bridges || []).forEach((br) => {
                if (br.active) {
                    ctx.fillStyle = br.color || '#74b9ff';
                    ctx.fillRect(br.x, br.y, br.width, br.height);
                    // í•˜ì´ë¼ì´íŠ¸
                    ctx.fillStyle = 'rgba(255,255,255,0.12)';
                    ctx.fillRect(br.x, br.y, br.width, 3);
                } else {
                    // ë¹„í™œì„±: ìœ„ì¹˜ íŒíŠ¸(ì ì„ )
                    ctx.strokeStyle = 'rgba(116,185,255,0.25)';
                    ctx.lineWidth = 2;
                    ctx.setLineDash([8, 6]);
                    ctx.strokeRect(br.x, br.y, br.width, br.height);
                    ctx.setLineDash([]);
                }
            });
            
            // ë¦¬í”„íŠ¸ (ë²„íŠ¼ ì—°ë™)
            (gameObjects.lifts || []).forEach((l) => {
                ctx.fillStyle = l.color || '#b2bec3';
                ctx.fillRect(l.x, l.y, l.width, l.height);
                // ìŠ¤íŠ¸ë¼ì´í”„
                ctx.fillStyle = 'rgba(0,0,0,0.2)';
                const stripes = Math.max(1, Math.floor(l.width / 24));
                for (let i = 0; i < stripes; i++) {
                    ctx.fillRect(l.x + 6 + i * 24, l.y + 3, 10, Math.max(1, l.height - 6));
                }
                // í•˜ì´ë¼ì´íŠ¸
                ctx.fillStyle = 'rgba(255,255,255,0.12)';
                ctx.fillRect(l.x, l.y, l.width, 2);
            });
            // ë²„íŠ¼
            gameObjects.buttons.forEach(b => {
                ctx.fillStyle = b.pressed ? '#2d3436' : b.color;
                ctx.fillRect(b.x, b.y + (b.pressed ? 10 : 0), b.width, b.height - (b.pressed ? 5 : 0));
                
                if (!b.pressed) {
                    ctx.fillStyle = 'rgba(255,255,255,0.3)';
                    ctx.fillRect(b.x, b.y, b.width, 3);
                }
            });
            
            // ë¬¸
            gameObjects.doors.forEach(d => {
                if (!d.open) {
                    ctx.fillStyle = d.color;
                    ctx.fillRect(d.x, d.y, d.width, d.height);
                    
                    // íŒ¨í„´
                    ctx.fillStyle = 'rgba(0,0,0,0.3)';
                    for (let i = 0; i < 3; i++) {
                        ctx.fillRect(d.x + 5, d.y + 10 + i * 30, d.width - 10, 20);
                    }
                } else {
                    // ì—´ë¦° ë¬¸
                    ctx.fillStyle = 'rgba(255,255,255,0.2)';
                    ctx.fillRect(d.x, d.y, d.width, d.height);
                }
            });
            
            // ìŠ¤íŒŒì´í¬
            gameObjects.spikes.forEach(s => {
                ctx.fillStyle = '#e74c3c';
                const spikeCount = Math.floor(s.width / 15);
                for (let i = 0; i < spikeCount; i++) {
                    ctx.beginPath();
                    ctx.moveTo(s.x + i * 15, s.y + s.height);
                    ctx.lineTo(s.x + i * 15 + 7.5, s.y);
                    ctx.lineTo(s.x + i * 15 + 15, s.y + s.height);
                    ctx.fill();
                }
            });
            
            // ë°•ìŠ¤
            gameObjects.boxes.forEach(box => {
                // ê·¸ë¦¼ì
                ctx.fillStyle = 'rgba(0,0,0,0.3)';
                ctx.fillRect(box.x + 4, box.y + 4, box.width, box.height);
                
                // ë°•ìŠ¤ ë³¸ì²´
                ctx.fillStyle = '#8b4513';
                ctx.fillRect(box.x, box.y, box.width, box.height);
                
                // ë‚˜ë¬´ ë¬´ëŠ¬
                ctx.fillStyle = '#a0522d';
                ctx.fillRect(box.x + 3, box.y + 3, box.width - 6, 8);
                ctx.fillRect(box.x + 3, box.y + box.height - 11, box.width - 6, 8);
                
                // í•˜ì´ë¼ì´íŠ¸
                ctx.fillStyle = 'rgba(255,255,255,0.2)';
                ctx.fillRect(box.x, box.y, box.width, 3);
                ctx.fillRect(box.x, box.y, 3, box.height);
                
                // í…Œë‘ë¦¬
                ctx.strokeStyle = '#5c3317';
                ctx.lineWidth = 2;
                ctx.strokeRect(box.x, box.y, box.width, box.height);
            });
            
            // ê³¨ - ê¹ƒë°œë§Œ í‘œì‹œ
            const goal = gameObjects.goal;
            const flagX = goal.x + goal.width / 2;
            const flagY = goal.y - 30; // ë” ë†’ê²Œ
            const flagHeight = goal.height + 30;
            
            // ê¹ƒë°œ ê¸°ë‘¥
            ctx.fillStyle = '#ffd700';
            ctx.fillRect(flagX - 3, flagY, 6, flagHeight);
            
            // ê¹ƒë°œ ì²œ
            ctx.beginPath();
            ctx.moveTo(flagX + 3, flagY);
            ctx.lineTo(flagX + 45, flagY + 22);
            ctx.lineTo(flagX + 3, flagY + 44);
            ctx.closePath();
            ctx.fillStyle = '#ff6b6b';
            ctx.fill();
            
            // ë°˜ì§ì´ íŒŒí‹°í´ 2~3ê°œ (ìì—°ìŠ¤ëŸ½ê²Œ ë– ë‹¤ë‹ˆëŠ” ëŠë‚Œ)
            const time = Date.now() / 1000;
            for (let i = 0; i < 3; i++) {
                const px = flagX + 20 + Math.sin(time * 0.8 + i * 2.5) * 25;
                const py = flagY + 20 + Math.cos(time * 0.6 + i * 2) * 20 + i * 10;
                const alpha = 0.6 + Math.sin(time * 2 + i) * 0.4;
                ctx.fillStyle = `rgba(255, 255, 150, ${alpha})`;
                ctx.beginPath();
                ctx.arc(px, py, 3, 0, Math.PI * 2);
                ctx.fill();
            }
            
            // ë‹¤ë¥¸ í”Œë ˆì´ì–´ë“¤ (íˆìŠ¤í† ë¦¬ ê¸°ë°˜ ë³´ê°„/ì˜ˆì¸¡ + ìŠ¤ë¬´ë”©)
            Object.entries(players).forEach(([sid, p]) => {
                const tp = getInterpolatedRemote(sid, p || {});
                const initX = (typeof tp.x === 'number') ? tp.x : 0;
                const initY = (typeof tp.y === 'number') ? tp.y : 0;
                const sp = smoothedPlayers[sid] || (smoothedPlayers[sid] = { x: initX, y: initY });

                const tx = (typeof tp.x === 'number') ? tp.x : 0;
                const ty = (typeof tp.y === 'number') ? tp.y : 0;
                let dx = tx - sp.x;
                let dy = ty - sp.y;
                const dist = Math.hypot(dx, dy);

                // ì•„ì£¼ ì‘ì€ ë³´ì •(íŒ¨í‚· ì§€í„°/ì„œë²„ ë¯¸ì„¸ êµì •)ë¡œ ì¸í•œ ëœëœ ë–¨ë¦¼ ë°©ì§€
                const DEAD = 0.18;
                if (Math.abs(dx) < DEAD) dx = 0;
                if (Math.abs(dy) < DEAD) dy = 0;

                // ìˆœê°„ì´ë™ê¸‰ ì°¨ì´ëŠ” ë°”ë¡œ ìŠ¤ëƒ… (ì‹¬í•œ ëŠê¹€/íŠ€ëŠ” ëŠë‚Œ ë°©ì§€)
                if (dist > 220) {
                    sp.x = tx;
                    sp.y = ty;
                } else {
                    // ê°€ê¹Œìš¸ìˆ˜ë¡ ë” ì²œì²œíˆ ë”°ë¼ê°€ì„œ ë¯¸ì„¸í•œ í”ë“¤ë¦¼ì„ í¡ìˆ˜
                    const k = dist < 8 ? 0.22 : 0.45;
                    sp.x += dx * k;
                    sp.y += dy * k;
                }

                sp.color = tp.color || p.color;
                sp.name = tp.name || p.name;
                sp.isDead = !!tp.isDead;
                sp.vx = (typeof tp.vx === 'number') ? tp.vx : (p.vx || 0);
                sp.vy = (typeof tp.vy === 'number') ? tp.vy : (p.vy || 0);
                sp.onGround = (typeof tp.onGround === 'boolean') ? tp.onGround : !!p.onGround;
                sp.pushing = !!tp.pushing;

                if (!sp.facing) sp.facing = 1;
                // ì›ê²©ì€ vxê°€ ì‘ì€ êµ¬ê°„ì—ì„œ ë¶€í˜¸ê°€ í”ë“¤ë¦¬ë©° ì¢Œìš°ë°˜ì „ì´ ê¹œë¹¡ì¼ ìˆ˜ ìˆì–´ ì„ê³„ê°’ì„ ì˜¬ë¦¼
                if (Math.abs(sp.vx) > 0.6) sp.facing = sp.vx < 0 ? -1 : 1;

                // ì›ê²© ìºë¦­í„°ëŠ” í”½ì…€ ìŠ¤ëƒ…(ì •ìˆ˜ ì¢Œí‘œ)ë¡œ ë Œë”ë§í•´ì„œ ëœëœ ë–¨ë¦¼ì„ ì¤„ì„
                const rx = (sp.vx < -0.15) ? Math.ceil(sp.x) : Math.floor(sp.x);
                const ry = Math.floor(sp.y);

                drawHamster(rx, ry, sp.color, sp.name, false, sp.isDead, { vx: sp.vx, vy: sp.vy, onGround: sp.onGround, facing: sp.facing, pushing: sp.pushing });
            });
// ë¡œì»¬ í”Œë ˆì´ì–´
            drawHamster(localPlayer.x, localPlayer.y, localPlayer.color, localPlayer.name, true, localPlayer.isDead, localPlayer);
            
            ctx.restore();
        }
        
                // ==================== ìºë¦­í„° ë Œë”ë§ (í”½ì…€ / 2ë“±ì‹  + ê·€/ê¼¬ë¦¬ + ê°„ë‹¨ ì• ë‹ˆë©”ì´ì…˜) ====================
        function _hexToRgb(hex){
            const h = (hex || '#000000').replace('#','').trim();
            const v = h.length === 3 ? h.split('').map(c=>c+c).join('') : h.padEnd(6,'0').slice(0,6);
            const n = parseInt(v,16);
            return { r:(n>>16)&255, g:(n>>8)&255, b:n&255 };
        }
        function _rgbToHex(r,g,b){
            const to = (x)=>('0'+Math.max(0,Math.min(255,Math.round(x))).toString(16)).slice(-2);
            return '#'+to(r)+to(g)+to(b);
        }
        function _shade(hex, amt){
            const {r,g,b} = _hexToRgb(hex);
            // amt: -100..100
            const f = (x)=> x + (amt/100) * (amt>0 ? (255-x) : x);
            return _rgbToHex(f(r), f(g), f(b));
        }

        function drawHamster(x, y, color, name, isLocal = false, isDead = false, state = null) {
            const s = state || {};
            const vx = (typeof s.vx === 'number') ? s.vx : 0;
            const vy = (typeof s.vy === 'number') ? s.vy : 0;
            const onGround = (typeof s.onGround === 'boolean') ? s.onGround : false;
            const facing = (typeof s.facing === 'number') ? s.facing : (vx < -0.2 ? -1 : 1);
            const variant = (typeof s.variant === 'number') ? s.variant : 0;
            const pushing = !!s.pushing || (typeof s.pushAnimUntil === 'number' && performance.now() < s.pushAnimUntil);

            // ì‚¬ë§ ì‹œ ë°˜íˆ¬ëª… ì²˜ë¦¬
            if (isDead) ctx.globalAlpha = 0.4;

            // ê·¸ë¦¼ì (ê¸°ì¡´ ìœ ì§€)
            ctx.fillStyle = 'rgba(0,0,0,0.2)';
            ctx.beginPath();
            ctx.ellipse(x + 20, y + 38, 14, 4, 0, 0, Math.PI * 2);
            ctx.fill();

            // í”½ì…€ ìŠ¤ì¼€ì¼/í¬ê¸°
            const PX = 2;         // 1px = 2 screen px
            const W = 16, H = 18; // sprite pixels (2ë“±ì‹  ëŠë‚Œ)
            const drawW = W * PX, drawH = H * PX;

            // íˆíŠ¸ë°•ìŠ¤(40x40) ë°”ë‹¥ì— ìŠ¤í”„ë¼ì´íŠ¸ë¥¼ ì •ë ¬
            const baseX = Math.round(x + 20 - drawW / 2);
            const baseY = Math.round(y + 40 - drawH);

            // ì• ë‹ˆë©”ì´ì…˜ íŒŒë¼ë¯¸í„°
            const t = performance.now() / 1000;
            const moving = onGround && Math.abs(vx) > 0.6;
            const jumping = !onGround && vy < -0.6;

            const walkPhase = moving ? (Math.floor(t * 10) % 2) : 0;
            const bob = moving ? Math.sin(t * 12) * 0.8 : Math.sin(t * 2.2) * 0.4;
            const bobPx = Math.round(bob); // pixel ë‹¨ìœ„

            // íŒ”/ë‹¤ë¦¬ í¬ì¦ˆ
            const armUp = jumping;
            const legsTuck = !onGround;
            const pushPose = pushing && !isDead;

            // ê¼¬ë¦¬ í”ë“¤ë¦¼
            const tailWag = moving ? (walkPhase ? 1 : -1) : (Math.sin(t * 3) > 0 ? 1 : -1);

            // ì»¬ëŸ¬ íŒ”ë ˆíŠ¸ (í”Œë ˆì´ì–´ ìƒ‰ ê¸°ë°˜)
            const OUT = _shade(color, -45);
            const BASE = color;
            const HI = _shade(color, 25);
            // ìš”ì²­: ì–¼êµ´(ì–¼êµ´/ë°° ì˜ì—­)ì€ ì‚´ìƒ‰ìœ¼ë¡œ ê³ ì •
            const FACE = '#f2c8a0';
            const HAIR = _shade(color, -65);
            const INNER = '#ffb8d0';
            const EYE = '#1f1f1f';
            const BLUSH = 'rgba(255,184,208,0.8)';

            // í”½ì…€ ê·¸ë¦¬ê¸° í—¬í¼
            const p = (px, py, w, h, c) => {
                if (w === undefined) w = 1;
                if (h === undefined) h = 1;
                ctx.fillStyle = c;
                ctx.fillRect(baseX + px * PX, baseY + (py + bobPx) * PX, w * PX, h * PX);
            };

            // ì¢Œìš° ë°˜ì „(ë°©í–¥)
            ctx.save();
            ctx.imageSmoothingEnabled = false;
            const cx = baseX + drawW / 2;
            const cy = baseY + drawH / 2;
            ctx.translate(cx, cy);
            ctx.scale(facing, 1);
            ctx.translate(-cx, -cy);

            // ===== ê¼¬ë¦¬ (ë¨¼ì €) =====
            const tw = tailWag;
            p(1 + (tw > 0 ? 0 : 1), 11, 2, 1, OUT);
            p(1 + (tw > 0 ? 0 : 1), 12, 3, 2, OUT);
            p(2 + (tw > 0 ? 0 : 1), 12, 2, 2, BASE);
            p(3 + (tw > 0 ? 0 : 1), 13, 1, 1, HI);

            // ===== ëª¸í†µ =====
            p(4, 9, 8, 7, OUT);
            p(5, 10, 6, 5, BASE);
            p(6, 11, 4, 3, FACE);
            // ê°œì„± í¬ì¸íŠ¸(ë°”ë”” ë¬´ëŠ¬)
            if (variant === 1) { p(6, 12, 4, 1, HI); }
            if (variant === 2) { p(7, 12, 2, 1, INNER); }
            if (variant === 3) { p(8, 11, 1, 2, HI); }


            // ===== ë¨¸ë¦¬ =====
            p(3, 2, 10, 8, OUT);
            p(4, 3, 8, 6, BASE);
            p(5, 4, 6, 4, FACE);

            // 4ëª… ê°ê° ì‘ì€ í¬ì¸íŠ¸(ìƒ‰/ì¥ì‹ë§Œ ë‹¤ë¥´ê²Œ)(ìƒ‰/ì¥ì‹ë§Œ ë‹¤ë¥´ê²Œ)
            if (variant === 0){
                // ë¦¬ë³¸
                p(3, 4, 1, 1, '#ffd1dc');
                p(4, 4, 1, 1, '#ffd1dc');
            } else if (variant === 1){
                // ë³„ ë¨¸ë¦¬í•€
                p(11, 3, 1, 1, '#ffe66d');
                p(12, 3, 1, 1, '#ffe66d');
            } else if (variant === 2){
                // í—¤ì–´ë°´ë“œ
                p(4, 3, 8, 1, 'rgba(255,255,255,0.9)');
            } else if (variant === 3){
                // ì‘ì€ ê½ƒ
                p(4, 5, 1, 1, '#ffb8d0');
                p(4, 6, 1, 1, '#ff6b6b');
            }

// ===== ê·€ =====
            p(4, 0, 3, 3, OUT);
            p(9, 0, 3, 3, OUT);
            p(5, 1, 2, 2, BASE);
            p(10, 1, 2, 2, BASE);
            p(6, 2, 1, 1, INNER);
            p(11, 2, 1, 1, INNER);

            // ===== íŒ” =====
            if (pushPose) {
                // ë°€ì¹˜ê¸° í¬ì¦ˆ: ì•íŒ”ì„ ë»—ê³  ëª¸ì„ ì‚´ì§ ì•ìœ¼ë¡œ
                p(2, 11, 2, 3, OUT);
                p(3, 12, 1, 2, BASE);

                // ì•ìª½(ì „ë©´) íŒ”
                p(12, 10, 3, 2, OUT);
                p(13, 11, 2, 1, BASE);
                p(15, 11, 1, 1, HI);
            } else if (armUp) {
                p(2, 8, 2, 2, OUT);
                p(12, 8, 2, 2, OUT);
                p(3, 9, 1, 1, BASE);
                p(12, 9, 1, 1, BASE);
            } else {
                p(3, 11, 2, 3, OUT);
                p(11, 11, 2, 3, OUT);
                p(4, 12, 1, 2, BASE);
                p(11, 12, 1, 2, BASE);
            }

            // ===== ë‹¤ë¦¬ =====
            if (legsTuck) {
                p(6, 15, 2, 2, OUT);
                p(8, 15, 2, 2, OUT);
                p(7, 16, 1, 1, BASE);
                p(9, 16, 1, 1, BASE);
            } else {
                const a = walkPhase ? 1 : 0;
                p(6, 15, 2, 2, OUT);
                p(9, 15, 2, 2, OUT);
                p(7, 16 - a, 1, 1, BASE);
                p(10, 16 - (1 - a), 1, 1, BASE);
            }

            // ===== ì–¼êµ´ =====
            // ===== ëˆˆ (ì„¸ë¡œ 2px) =====
            p(6, 6, 1, 2, EYE);
            p(10, 6, 1, 2, EYE);
            // í•˜ì´ë¼ì´íŠ¸(ìœ„ìª½ 1px)
            p(6, 5, 1, 1, 'rgba(255,255,255,0.9)');
            p(10, 5, 1, 1, 'rgba(255,255,255,0.9)');
            // ì½”/ì…
            p(8, 7, 1, 1, INNER);
            p(8, 8, 2, 1, OUT);

            // ë³¼í„°ì¹˜
            ctx.fillStyle = BLUSH;
            ctx.fillRect(baseX + 5 * PX, baseY + (8 + bobPx) * PX, 2 * PX, 1 * PX);
            ctx.fillRect(baseX + 9 * PX, baseY + (8 + bobPx) * PX, 2 * PX, 1 * PX);

            // ë¡œì»¬ í‘œì‹œ(í”½ì…€ í™”ì‚´í‘œ)
            if (isLocal && !isDead) {
                p(7, -2, 2, 1, '#ffd700');
                p(8, -3, 1, 1, '#ffd700');
            }

            // ì‚¬ë§ í‘œì‹œ (í”½ì…€ X)
            if (isDead) {
                ctx.globalAlpha = 1;
                ctx.fillStyle = '#ff3b3b';
                for (let i = 0; i < 6; i++) {
                    ctx.fillRect(baseX + (5 + i) * PX, baseY + (4 + i + bobPx) * PX, PX, PX);
                    ctx.fillRect(baseX + (10 - i) * PX, baseY + (4 + i + bobPx) * PX, PX, PX);
                }
            }

            ctx.restore();

            // ì´ë¦„í‘œ (ì´ë¦„ì´ ìˆì„ ë•Œë§Œ)
            if (name) {
                ctx.fillStyle = 'rgba(0,0,0,0.6)';
                ctx.beginPath();
                ctx.roundRect(x - 5, y - 15, 50, 14, 7);
                ctx.fill();

                ctx.fillStyle = '#fff';
                ctx.font = '9px Jua';
                ctx.textAlign = 'center';
                ctx.fillText(name, x + 20, y - 4);
            }

            // globalAlpha ë³µì›
            ctx.globalAlpha = 1;
        }

        // ==================== ê²Œì„ ë£¨í”„ ====================
        function gameLoop() {
            if (!gameRunning) return;
            updatePhysics();
            render();
            rafId = requestAnimationFrame(gameLoop);
        }
        
        
        // ==================== Colyseus ë¸Œë¦¿ì§€ (Firebase ì œê±°) ====================
        let mySessionId = null;
        let mySeat = 0;
        let tgEnded = false; // embed ë©€í‹°ì—ì„œ ê²°ê³¼ ì „ì†¡ ì¤‘ë³µ ë°©ì§€

        function bridgeSendOver(success, reason){
            if (!EMBED || isGuestMode) return;
            if (tgEnded) return;
            tgEnded = true;
            bridgeSend("tg_over", { success: !!success, reason: reason || (success ? "clear" : "fail") });
        }

        // ==================== ì›ê²© í”Œë ˆì´ì–´ ë³´ê°„/ì˜ˆì¸¡ ====================
        function recordRemoteSnapshot(sid, p){
            const now = performance.now();
            const arr = remoteHistory[sid] || (remoteHistory[sid] = []);
            arr.push({
                t: now,
                x: (p && typeof p.x === 'number') ? p.x : (p?.x || 0),
                y: (p && typeof p.y === 'number') ? p.y : (p?.y || 0),
                vx: (p && typeof p.vx === 'number') ? p.vx : (p?.vx || 0),
                vy: (p && typeof p.vy === 'number') ? p.vy : (p?.vy || 0),
                onGround: !!p?.onGround,
                isDead: !!p?.isDead,
                color: p?.color,
                name: p?.name,
                variant: (typeof p?.variant === 'number') ? p.variant : 0,
                pushing: !!p?.pushing
            });

            // íˆìŠ¤í† ë¦¬ ì •ë¦¬
            const cutoff = now - NET_MAX_HISTORY_MS;
            while (arr.length > 2 && arr[1].t < cutoff) arr.shift();
            if (arr.length > 80) arr.splice(0, arr.length - 80);
        }

        function getInterpolatedRemote(sid, fallback){
            const hist = remoteHistory[sid];
            const now = performance.now();
            const renderT = now - NET_INTERP_DELAY_MS;
            if (!hist || hist.length === 0) return fallback || { x: 0, y: 0 };

            // ë„ˆë¬´ ì˜¤ë˜ëœ íˆìŠ¤í† ë¦¬ ì •ë¦¬
            const cutoff = now - NET_MAX_HISTORY_MS;
            while (hist.length > 2 && hist[1].t < cutoff) hist.shift();

            // renderT ì´ì „ì˜ ë§ˆì§€ë§‰ ìŠ¤ëƒ…ìƒ· ì°¾ê¸°
            let i = 0;
            while (i < hist.length - 1 && hist[i + 1].t <= renderT) i++;

            const a = hist[i];
            const b = hist[i + 1];

            // êµ¬ê°„ ë³´ê°„
            if (b && a.t <= renderT && renderT <= b.t) {
                const span = (b.t - a.t) || 1;
                const alpha = (renderT - a.t) / span;
                return {
                    x: a.x + (b.x - a.x) * alpha,
                    y: a.y + (b.y - a.y) * alpha,
                    vx: b.vx,
                    vy: b.vy,
                    onGround: !!b.onGround,
                    isDead: !!b.isDead,
                    color: b.color,
                    name: b.name,
                    variant: (typeof b.variant === 'number') ? b.variant : 0,
                    pushing: !!b.pushing
                };
            }

            // ìµœì‹  ìŠ¤ëƒ…ìƒ· ì´í›„ë©´ ì§§ê²Œ ì˜ˆì¸¡ (ëŠê¹€ ì™„í™”)
            const last = hist[hist.length - 1];
            const dtMs = Math.max(0, Math.min(200, renderT - last.t));
            const frames = dtMs / 16.6667;
            const g = 0.4;
            return {
                x: last.x + (last.vx || 0) * frames,
                y: last.y + (last.vy || 0) * frames + 0.5 * g * frames * frames,
                vx: last.vx,
                vy: last.vy,
                onGround: !!last.onGround,
                isDead: !!last.isDead,
                color: last.color,
                name: last.name,
                variant: (typeof last.variant === 'number') ? last.variant : 0,
                pushing: !!last.pushing
            };
        }

        function getRemotePosForLogic(sid, p){
            // Use smoothed(render) position when available to avoid visible gaps / mismatch.
            try{
                const sp = smoothedPlayers && smoothedPlayers[sid];
                if (sp && typeof sp.x === 'number' && typeof sp.y === 'number'){
                    return { x: sp.x, y: sp.y };
                }
            }catch(_){ }
            const rp = getInterpolatedRemote(sid, p || {});
            const x = (typeof rp.x === 'number') ? rp.x : ((p && typeof p.x === 'number') ? p.x : (p?.x || 0));
            const y = (typeof rp.y === 'number') ? rp.y : ((p && typeof p.y === 'number') ? p.y : (p?.y || 0));
            return { x, y };
        }

        function applyRemotePlayers(map){
            const next = {};
            if (!map) map = {};
            for (const [sid, p] of Object.entries(map)){
                if (sid === mySessionId) continue;
                next[sid] = p;
                // ìŠ¤ëƒ…ìƒ· ê¸°ë¡ (ë³´ê°„/ì˜ˆì¸¡)
                recordRemoteSnapshot(sid, p);
                // init smoothing slot
                if (!smoothedPlayers[sid]){
                    smoothedPlayers[sid] = { x: p.x||0, y: p.y||0, vx: p.vx||0, vy: p.vy||0, onGround: !!p.onGround, isDead: !!p.isDead, pushing: !!p.pushing };
                }
                // keep name/color immediately (no alpha)
                smoothedPlayers[sid].name = p.name;
                smoothedPlayers[sid].color = p.color;
                smoothedPlayers[sid].variant = (typeof p.variant === 'number') ? p.variant : 0;
                smoothedPlayers[sid].pushing = !!p.pushing;
            }
            players = next;
            // prune removed
            for (const sid of Object.keys(smoothedPlayers)){
                if (!players[sid]) delete smoothedPlayers[sid];
            }
            for (const sid of Object.keys(remoteHistory)){
                if (!players[sid]) delete remoteHistory[sid];
            }
            updatePlayerList();
        }

        function applyButtons(btnMap){
            if (!btnMap || !gameObjects?.buttons) return;
            for (const [idxStr, pressed] of Object.entries(btnMap)){
                const idx = parseInt(idxStr, 10);
                if (gameObjects.buttons[idx]) gameObjects.buttons[idx].pressed = !!pressed;
            }
            updateDoors();
            updateBridges();
            updateLifts();
        }

        function bridgeSendState(force=false){
            if (!EMBED || isGuestMode) return;
            const now = performance.now();
            if (!force && bridgeSendState._t && (now - bridgeSendState._t) < 33) return; // ~20Hz
            bridgeSendState._t = now;
            bridgeSend("tg_state", {
                state: {
                    x: localPlayer.x, y: localPlayer.y,
                    vx: localPlayer.vx, vy: localPlayer.vy,
                    onGround: !!localPlayer.onGround,
                    onButton: !!localPlayer.onButton,
                    isDead: !!localPlayer.isDead,
                    color: localPlayer.color,
                    name: localPlayer.name,
                    level: currentLevel,
                    deathCount,
                    variant: localPlayer.variant,
                    pushing: (performance.now() < (localPlayer.pushAnimUntil || 0))
                }
            });
        }

        // Embed ëª¨ë“œ ì§„ì…: ë‚´ë¶€ ë¡œë¹„/ì„¤ì • UI ì œê±°, ë¶€ëª¨ì—ê²Œ ì¤€ë¹„ ì‹ í˜¸
        if (EMBED){
            try{
                const lobby = document.getElementById('lobby');
                if (lobby){
                    // ë¡œë¹„ UIëŠ” ë¶€ëª¨ ë¡œë¹„ë¥¼ ì‚¬ìš©í•˜ë¯€ë¡œ ìµœì†Œí™”
                    const hide = lobby.querySelectorAll('button, details, .input-group');
                    hide.forEach(el => el.style.display = 'none');
                    const subtitle = lobby.querySelector('.lobby-subtitle');
                    if (subtitle) subtitle.textContent = 'ì—°ê²° ì¤‘...';
                }
                bridgeSend("bridge_ready", {});
            }catch(e){}
        }

        window.addEventListener("message", (e)=>{
            const d = e.data || {};
            if (!d || typeof d !== "object") return;

            if (d.type === "bridge_init"){
                mySessionId = String(d.sessionId || "");
                mySeat = typeof d.seat === "number" ? d.seat : 0;
                startEmbedded({
                    nick: d.nick || "í–„ì°Œ",
                    seat: mySeat,
                    isHost: !!d.isHost,
                    sessionId: mySessionId,
                    roomCode: d.roomCode || "ROOM",
                    practice: !!d.practice
                });
                if (d.players) applyRemotePlayers(d.players);
                if (d.level) {
                    const lv = parseInt(d.level, 10);
                    if (lv) { currentLevel = lv; }
                }
                return;
            }

            if (d.type === "tg_players"){
                applyRemotePlayers(d.players || {});
                return;
            }

            if (d.type === "tg_level"){
                const lv = parseInt(d.level, 10);
                if (lv && lv !== currentLevel){
                    currentLevel = lv;
                    loadLevel(currentLevel);
                }
                return;
            }

            if (d.type === "tg_buttons"){
                applyButtons(d.buttons || {});
                return;
            }

            if (d.type === "tg_button"){
                if (gameObjects?.buttons && gameObjects.buttons[d.idx]){
                    gameObjects.buttons[d.idx].pressed = !!d.pressed;
                    updateDoors();
                    updateBridges();
                    updateLifts();
                }
                return;
            }

            if (d.type === "tg_push"){
                const to = String(d.to || "");
                if (to && mySessionId && to !== mySessionId) return;
                const dx = clamp(Number(d.dx) || 0, -16, 16);
                const dy = clamp(Number(d.dy) || 0, -16, 16);
                const now = performance.now();
                // Remember knockback so it is not immediately overwritten by local movement input
                localPlayer.knockbackUntil = now + 320;
                if (!dx && !dy) return;
                // Apply impulse (horizontal + slight lift)
                if (dx){
                    localPlayer.x += dx;
                    localPlayer.knockbackVx = clamp((localPlayer.knockbackVx || 0) + dx * 0.95, -12, 12);
                    localPlayer.vx = clamp((localPlayer.vx || 0) + dx * 0.55, -12, 12);
                }
                if (dy){
                    localPlayer.y += dy * 0.25;
                    localPlayer.vy = clamp((localPlayer.vy || 0) + dy * 0.55, JUMP_VELOCITY * 1.4, MAX_FALL_SPEED);
                    if (dy < 0) localPlayer.onGround = false;
                }
                try{ sfxPush(); }catch(_){ }
                bridgeSendState(true);
                return;
            }

            if (d.type === "tg_floors"){
                // full sync of floors (may arrive before level is ready)
                const arr = Array.isArray(d.floors) ? d.floors : [];
                if (!gameObjects || !gameObjects.platforms){
                    pendingFloorFullSync = arr;
                    pendingFloorAdds = [];
                    pendingFloorAddSet.clear();
                    pendingFloorRemoves = [];
                    return;
                }
                clearAllFloors();
                for (const pl of arr) addFloorPlatform(pl);
                return;
            }

            if (d.type === "tg_floor") {
                // Floor broadcast (server may echo our own floor). Duplicates are ignored by addFloorPlatform.
                addFloorPlatform(d);
                return;
            }

            if (d.type === "tg_floor_remove"){
                if (!gameObjects || !gameObjects.platforms){
                    pendingFloorRemoves.push({ owner: d.owner || null, ids: Array.isArray(d.ids) ? d.ids : null });
                    return;
                }
                if (d.ids && Array.isArray(d.ids)) {
                    for (const id of d.ids) removeFloorById(id);
                } else if (d.owner) {
                    removeFloorsByOwner(d.owner);
                }
                return;
            }

            if (d.type === "tg_reset"){
                showDeathEffect(()=> resetMap());
                return;
            }
        });

// í˜ì´ì§€ ë¡œë“œì‹œ ì €ì¥ëœ ì´ë¦„ ë³µì›
        const savedName = localStorage.getItem('playerName');
        if (savedName) {
            document.getElementById('playerName').value = savedName;
        }
        
        document.getElementById('playerName').addEventListener('change', (e) => {
            localStorage.setItem('playerName', e.target.value);
        });
    </script>

<script>
(function(){
  function ping(){
    try{
      if (window.parent && window.parent !== window){
        window.parent.postMessage({ type: "tg_iframe_tap" }, "*");
      }
    }catch(e){}
  }
  window.addEventListener("pointerdown", ping, { passive: true });
  window.addEventListener("touchstart", ping, { passive: true });
  window.addEventListener("mousedown", ping, { passive: true });
})();
</script>

</body>
</html>
